/* ***** BEGIN LICENSE BLOCK *****
 * Version: GNU GPL 2.0
 *
 * The contents of this file are subject to the
 * GNU General Public License Version 2.0; you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * ***** END LICENSE BLOCK ***** */


(function DefaultModule() {
	
	this.name = this.constructor.name;
	var _mod = this;
	
	
	function TemporaryNick() {
		
		return 'tmp'+Math.random().toString(16).substr(2);
	}
	
// [TBD] autodetect max message length ( with a self sent mesage )
// [TBD] autodetect flood limit

	this.messageListener = {
	
	
		RPL_WELCOME: function( command, from, to ) {

			setData(_mod.data.nick, to);
			_mod.state.Toggle( 'rightNick', getData(_mod.data.nick) == getData(_mod.data.wishNick) );
		},

/*
		ERR_NONICKNAMEGIVEN
		ERR_ERRONEUSNICKNAME
		ERR_NICKNAMEINUSE
		ERR_NICKCOLLISION
		ERR_UNAVAILRESOURCE
		ERR_RESTRICTED
*/

		NICK:function( command, who, nick ) {

			setData( _mod.data.nick, nick );
			_mod.state.Toggle( 'rightNick', getData(_mod.data.nick) == getData(_mod.data.wishNick) );
		},


		ERR_RESTRICTED: function() {

			_mod.api.Nick( TemporaryNick() );
		},

		ERR_NICKCOLLISION: function() {
			
			_mod.api.Nick( TemporaryNick() );
		},

		ERR_ERRONEUSNICKNAME: function() { // Erroneous nickname
		  
			_mod.api.Nick( TemporaryNick() );
		},

		ERR_NICKNAMEINUSE: function() { // ...try a random nick, then, when ready, periodically try a better nick
			
			_mod.api.Nick( TemporaryNick() );
		},




		RPL_USERHOST: function( command, from, to, hostList ) {
			
			if ( to == getData(_mod.data.nick) ) {
				
				var host = StrBefore(hostList, ' ');
				setData( _mod.data.userhost, host.substr(host.lastIndexOf('=')+1) ); // hostinfo[0] = '+' or '-' : AWAY message set ???
			}
		},
		
		PING: function( command, prefix, arg ) {

			_mod.Send( 'PONG '+arg );
			setData( _mod.data.lastPingTime, Now() );
		},

		NOTICE: function( command, from, to, message ) {

			// irc.clockworkorange.co.uk- on 1 ca 1(2) ft 10(10) tr
			// where:
			//  on = Number of globally connected clients including yourself from your IP-number.
			//  ca = Connect Attempts, You have tried once, after 2 sequential connects you get throttled.
			//  ft = Free Targets. This is how many different people you may contact at once, also see 3.10
			//  tr = Targets Restored. Your targets are kept for 2 minutes or until someone else from your IP logs on. 
			//       This stops you from  refilling  your free targets by reconnection.	
/*
			if ( message.substr(0,2) == 'on' ) {

				var res = /on ([0-9]+) ca ([0-9]+)\(([0-9]+)\) ft ([0-9]+)\(([0-9]+)\) *(tr)?$/(message);
				if ( res == null )
					return;
//				_mod.RemoveMessageListener( 'NOTICE', oncafttrNotice );
			}
*/
		}
	};
	
	// export module API
	_mod.moduleApi = {
	
		ToIRCLowerString: function( str ) { // {}|^ are considered to be the lower case equivalents of the characters []\~
			
			str = str.replace('[', '{');
			str = str.replace(']', '}');
			str = str.replace('\\', '|');
			str = str.replace('~', '^');
			return str.toLowerCase();
		},

		ToIRCUpperString: function( str ) {

			str = str.replace('{', '[');
			str = str.replace('}', ']');
			str = str.replace('|', '\\');
			str = str.replace('^', '~');
			return str.toUpperCase();
		},

		Topic: function( channel, topic ) void _mod.Send( 'TOPIC '+channel+' :'+topic ),
		
		Nick: function( nick ) void _mod.Send( 'NICK '+nick ),
		
		Privmsg: function( to, messages, OnSent ) {
			
			if( !(messages instanceof Array) )
				messages = [messages];
			_mod.Send( [ 'PRIVMSG '+StrBefore(to,'!')+' :'+message for each ( message in messages ) ], false, OnSent )
		},

		// freenode network do not send a quit message if the client is connected for less than 5 mimutes
		Quit: function(quitMessage) _mod.Send( 'QUIT :'+quitMessage, true ) // true = force the message to be post ASAP
	}

	var LagProbe = new function() {
		
		for (;;) {

			_mod.Send( 'PING LAG'+IntervalNow(), true );
			yield function(callback) io.AddTimeout( getData(_mod.data[_mod.name].lagProbeInterval), callback ); // async pause
		}
	}
	
	
		
	var LagProbeResponse = {
	
		PONG: function( command, from, server, data ) {
	
			if ( data.substr(0,3) == 'LAG' )
				setData( _mod.data.ping, IntervalNow() - parseInt(data.substr(3)) );
		}
	}

	this.stateListener = [
		{
			set: function(s) s.connected,
			reset: False, // never resets
			trigger: function(polarity) {

				_mod.Send( 'NICK '+getData(_mod.data.wishNick) );
				_mod.Send( 'USER '+getData(_mod.data.ident.username)+' '+getData(_mod.data.hostname)+' '+getData(_mod.data.server)+' :'+getData(_mod.data.ident.realname) );
			}
		},
		{
			set: function(s) s.interactive,
			reset: function(s) !s.interactive,
			trigger: function(polarity) {

				_mod.ToggleMessageListener( LagProbeResponse, polarity );
				ToggleAsyncProc( LagProbe, polarity );

				if ( polarity )
					_mod.Send( 'USERHOST '+getData(_mod.data.nick) );
			}
		}
	];
})
