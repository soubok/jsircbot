(function webConsoleModule($D, $A, $S) {
	
	LoadModule('jsz');
	
	this.disabled = false;
	var _name = this.name = this.constructor.name;
	var $MD = $D[_name];

	var maxConnections = 3;
	var count = 0;
	var serverConnection;
	var port = 80;


	const mimeType = {
		html:'text/html',
		gif:'image/gif',
		jpeg:'image/jpeg',
		jpg:'image/jpeg',
		jpe:'image/jpeg',
		svg:'image/svg+xml'
	};

	const statusText = { 
		200:'OK', 
		404:'Not Found' 
	};

	// Tools

	function MimeTypeByFileName(fileName) {

		return mimeType[fileName.substr(fileName.lastIndexOf(DOT)+1)] || 'text/html; charset=iso-8859-1';
	}

	function NormalizeHeaderName(rawName) {

		return rawName.toLowerCase().split('-').join('');
	}

	function ParseHeaders(buffer) {

//		log.WriteLn(buffer);
		try {
			var lines = buffer.split(CRLF);
			var [method,url,proto] = lines[0].split(SPC);
			var httpVersion = Number(proto.split(SLASH)[1]);
			var [path,query] = url.split('?');
			var status = { method:method, url:url, httpVersion:httpVersion, path:path, query:query };
			var headers = {};
			for ( var i=1; lines[i].length; i++ ) {
				var [name,value] = lines[i].split(':');
				headers[NormalizeHeaderName(name)] = Trim(value);
			}
		} catch(error) {
//			log.WriteLn('Error while parsing headers :\n'+buffer);
			throw new Halt( 'header parsing error (see log file)' );
		}
		return [ status, headers ];
	}

	function CreateHttpHeaders( status, headers ) {

		var buf = 'HTTP/1.1' + SPC + status + SPC + statusText[status] + CRLF;
		for ( var [h,v] in Iterator(headers) )
			buf += h + ': ' + v + CRLF;
		return buf + CRLF;
	}

	
	function Console(output) {
		
		var file = new File('./webConsole.html'); // (TBD) from config
		var template = file.content;
		this.input = function() {
		}
	}




	function NormalizePath( path ) { // (TBD) try with regexp

		var epath = path.split('/');
		var newPath = [];
		for each ( var name in epath )
			switch (name) {
			case '..':
				newPath.pop();
				break;
			case '.':
			case '':
				break;
			default:
				newPath.push(name);
			}
		return newPath.join('/');
	}



	function ProcessRequest( status, headers, output, close ) {

		var root='./';
		var data = '';

		var file = new File( root + NormalizePath(status.path) );
		if ( !file.exist || file.info.type != File.FILE_FILE ) {

			var message = 'file not found';
			output(CreateHttpHeaders( 404, {'Content-Length':message.length, 'Content-Type':'text/plain'} ));
			output(message);
			return Noop;
		}


		return function(chunk) {

			if ( !chunk ) {
			
			Print( 'Got All Data', '\n')

				var respondeHeaders = {};
				respondeHeaders['Content-Type'] = MimeTypeByFileName( status.path );


				var useChunksEncoding = false;
				var useKeepAliveConnection = false;


				if (status.httpVersion == 1.1) {
					useKeepAliveConnection = true;
					useChunksEncoding = true;				
				}

				if (useKeepAliveConnection)
					respondeHeaders['Connection'] = 'Keep-Alive';

				if (useChunksEncoding)
					respondeHeaders['Transfer-Encoding'] = 'chunked';


				var SendChunk = Identity;
				var ContentEncoding = Identity;

				if ( headers.acceptencoding && headers.acceptencoding.indexOf('deflate') != -1 ) {

					respondeHeaders['Content-Encoding'] = 'deflate';
					ContentEncoding = new Z(Z.DEFLATE);
				}

				file.Open( File.RDONLY );

				//1
				output( CreateHttpHeaders( 200, respondeHeaders ) );
				
				//2
				output( function(chunks) {

					var data = file.Read(Z.idealInputLength);

					data = ContentEncoding(data);

					if ( data.length ) {

						if ( useChunksEncoding )
							chunks.push( data.length.toString(16) + CRLF, data, CRLF );
						else
							chunks.push( data );

						return true; // continue
					}
					file.Close();
					return false;
				} );
				
				//3
				if ( useChunksEncoding )
					output( '0' + CRLF + CRLF );

				//4
				if ( !useKeepAliveConnection )
					output(close); // close the socket
			} else {
	
				data += chunk;
			}
		}
	}



	function ProcessConnection(connection) {

		var _input = '';
		var _output = [];

		function ProcessOutput() {

			if ( _output.length ) {

				var dataInfo = _output[0];
				if ( dataInfo instanceof Function ) {
					var chunks = [];
					dataInfo(chunks) || _output.shift(); // ''exhausted'' function
					if ( chunks.length == 0 )
						return; // cannot shift here because the next item may be a Function
					_output = chunks.concat(_output);
				}
				connection.Write( _output.shift() );
			}
//			else
//				delete s.writable;
		}

		function Output( dataInfo ) {

			_output.push(dataInfo);
			
			//s.writable = ProcessOutput;
			while ( _output.length )
				ProcessOutput();
		}

		function Close() {

			connection.Close();
		}

		function ProcessHeaders() {

			_input && Next('');
			connection.OnData = function(data) { 

				Next( data );
				data.length || connection.Close();
			}

			function Next(chunk) {

				_input += chunk;
				var eoh = _input.indexOf( CRLF + CRLF );
				if ( eoh == -1 )
					return;
				var [status,headers] = ParseHeaders( _input.substr(0, eoh+4) );
				status.peerName = connection.peerName;
				_input = _input.substr(eoh+4);

Print( status.peerName + ' ' + status.method + ' ' + status.path, '\n' );

				switch (status.method) {
				case 'POST':
					ProcessBody( status, headers );
					break;
				case 'GET':
					ProcessRequest( status, headers, Output, Close )();
					break;
				}
			}
		}


		function ProcessBody( status, headers ) {

			var length = headers.contentlength; //['content-length'];

			var pr = ProcessRequest( status, headers, Output, Close );
			
//			if ( length != undefined && length == 0 ) {
//				pr();
//				ProcessHeaders();
//				return; // (TBD) need optimization
//			}

			//_input && Next('');
			Next('');

			connection.OnData = function(data) {
				
				Next( data );
//				data.length || connection.Close(); // why closing the connection here ?
			}

			function Next(chunk) {

				_input += chunk;

				if ( length == undefined ) {

					pr(_input);
					_input = '';
					return;
				}

				if ( _input.length < length ) {

					length -= _input.length;
					pr(_input);
					_input = '';
				} else {

					pr(_input.substr(0,length));
					_input = _input.substr(length);
					pr(); // end
					ProcessHeaders();
				}
			}
		}

		ProcessHeaders();
	}
	
	
	function IncomingConnectionProc(connection) {
		
		var input = '';
		var eoh;
		
		do {
			var [data] = yield AsyncConnectionRead(connection);
			input += data;
			eoh = input.indexOf(CRLF + CRLF);
		} while(eoh == -1);
		
		var [status,headers] = ParseHeaders( input.substr(0, eoh+4) );
		status.peerName = connection.peerName;
		input = input.substr(eoh+4);
		
		
		Print(headers.toSource());
	}


	function StartServer() {
	
		serverConnection = new TCPServer( port, undefined, 3 );
		serverConnection.OnIncoming = function(connection) {

			if ( count > maxConnections ) {
			
				connection.Close();
			} else {
				
				count++;
				//ProcessConnection(connection);
				StartAsyncProc( IncomingConnectionProc(connection) );
			}
		}
	}
	
	
	this.moduleListener = {
	};
	
	this.moduleApi = {
	};	
	
	this.stateListener = [
		{
			set: function(s) s[STATE_RUNNING] && s[_name],
			reset: function(s) !s[STATE_RUNNING] || !s[_name],
			trigger: function(polarity) {
			
				if (polarity) {
					
					StartServer();

				} else {
					// kill all consoles
				}
				
			}
		}
	];	

})
