/* ***** BEGIN LICENSE BLOCK *****
 * Version: GNU GPL 2.0
 *
 * The contents of this file are subject to the
 * GNU General Public License Version 2.0; you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * ***** END LICENSE BLOCK ***** */

(function webConsoleModule($D, $A, $S) {
	
	LoadModule('jsz');
	
	this.disabled = false;
	var _name = this.name = this.constructor.name;
	var $MD = $D[_name];

	var maxConnections = 3;
	var count = 0;
	var serverConnection;
	var port = 80;


	const mimeType = {
		html:'text/html',
		gif:'image/gif',
		jpeg:'image/jpeg',
		jpg:'image/jpeg',
		jpe:'image/jpeg',
		svg:'image/svg+xml'
	};

	const reasonPhrase = {
		100: 'Continue',
		101: 'Switching Protocols',
		
		200: 'OK',
		201: 'Created',
		202: 'Accepted',
		203: 'Non-Authoritative Information',
		204: 'No Content',
		205: 'Reset Content',
		206: 'Partial Content',
		
		300: 'Multiple Choices',
		301: 'Moved Permanently',
		302: 'Found',
		303: 'See Other',
		304: 'Not Modified',
		305: 'Use Proxy',
		307: 'Temporary Redirect',
		
		400: 'Bad Request',
		401: 'Unauthorized',
		402: 'Payment Required',
		403: 'Forbidden',
		404: 'Not Found',
		405: 'Method Not Allowed',
		406: 'Not Acceptable',
		407: 'Proxy Authentication Required',
		408: 'Request Time-out',
		409: 'Conflict',
		410: 'Gone',
		411: 'Length Required',
		412: 'Precondition Failed',
		413: 'Request Entity Too Large',
		414: 'Request-URI Too Large',
		415: 'Unsupported Media Type',
		416: 'Requested range not satisfiable',
		417: 'Expectation Failed',
		
		500: 'Internal Server Error',
		501: 'Not Implemented',
		502: 'Bad Gateway',
		503: 'Service Unavailable',
		504: 'Gateway Time-out',
		505: 'HTTP Version not supported'
	};




	// Tools

	function MimeTypeByFileName(fileName) {

		return mimeType[fileName.substr(fileName.lastIndexOf(DOT)+1)] || 'text/html; charset=iso-8859-1';
	}

	function NormalizeHeaderName(rawName) {

		return rawName.toLowerCase().split('-').join('');
	}

	function ParseHeaders(buffer) {

//		log.WriteLn(buffer);
		try {
			var lines = buffer.split(CRLF);
			var [method,url,proto] = lines[0].split(SPC);
			var httpVersion = Number(proto.split(SLASH)[1]);
			var [path,query] = url.split('?');
			var status = { method:method, url:url, httpVersion:httpVersion, path:path, query:query };
			var headers = {};
			for ( var i=1; lines[i].length; i++ ) {
				var [name,value] = lines[i].split(':');
				headers[NormalizeHeaderName(name)] = Trim(value);
			}
		} catch(error) {
//			log.WriteLn('Error while parsing headers :\n'+buffer);
			throw new Halt( 'header parsing error (see log file)' );
		}
		return [ status, headers ];
	}

	function CreateHttpHeaders( status, headers ) {

		var buf = 'HTTP/' + status.httpVersion + SPC + status.code + SPC + reasonPhrase[status.code] + CRLF;
		for ( var [h,v] in Iterator(headers) )
			buf += h + ': ' + v + CRLF;
		return buf + CRLF;
	}

	
	function Console(output) {
		
		var file = new File('./webConsole.html'); // (TBD) from config
		var template = file.content;
		this.input = function() {
		}
	}




	function NormalizePath( path ) { // (TBD) try with regexp

		var epath = path.split('/');
		var newPath = [];
		for each ( var name in epath )
			switch (name) {
			case '..':
				newPath.pop();
				break;
			case '.':
			case '':
				break;
			default:
				newPath.push(name);
			}
		return newPath.join('/');
	}



	function ProcessFileRequest( iStatus, iHeaders, oStatus, oHeaders, Respond ) {

		var root='./';
		var data = '';
		
		var fileName = root + NormalizePath(iStatus.path);
		var file = new File( fileName );
		if ( !file.exist || file.info.type != File.FILE_FILE ) {

			var message = 'file '+fileName+' not found';
			
			oStatus.code = 404;
			oHeaders['Content-Length'] = message.length;
			oHeaders['Content-Type'] = 'text/plain';
			var output = Respond();
			output(message);
			return;
		}
		
		oStatus.code = 200;
		
		this.OnData = function(buf) {
			
			data += buf;
		}

		this.OnEndOfData = function() {

			oHeaders['Content-Type'] = MimeTypeByFileName( fileName );

			var useChunksEncoding = false;
			if (iStatus.httpVersion == 1.1) {
			
				useChunksEncoding = true;				
				oHeaders['Transfer-Encoding'] = 'chunked';
			}

			var ContentEncoding = Identity;
			if ( iHeaders.acceptencoding && iHeaders.acceptencoding.indexOf('deflate') != -1 ) {

				oHeaders['Content-Encoding'] = 'deflate';
				ContentEncoding = new Z(Z.DEFLATE);
			}


			file.Open( File.RDONLY );
			
			//1
			var output = Respond();

			//2
			output( function() {

				var data = file.Read(Z.idealInputLength);
				if ( data.length ) {

					data = ContentEncoding(data);
					if ( useChunksEncoding )
						return [ data.length.toString(16) + CRLF, data, CRLF ];
					else
						return [ data ];
				}
				file.Close();
				return false;
			} );

			//3
			if ( useChunksEncoding )
				output( '0' + CRLF + CRLF );
		}
	}
	


	connectionCount = 0;

	function ProcessConnectionProc(connection, remainRequestCount, keepAliveTimeout) {

		connectionCount++;
		
		var input=new Buffer(), output=[];

		function ProcessOutputData() {

			if ( output.length ) {
			
				dataInfo = output[0];
				if ( dataInfo instanceof Function ) {
				
					var chunks = dataInfo();
					if ( chunks )
						output = chunks.concat(output);
					else	
						output.shift(); // function is ''exhausted''
				}
				connection.Write( output.shift(), true, ProcessOutputData ); // 'true' for async write
			}
		}

		function SendData( dataInfo ) {

			output.push(dataInfo);
			ProcessOutputData();
		}


		requestLoop:
		do {

			var status, data, pr, eoh;

			[status] = yield AsyncConnectionWaitData(connection, keepAliveTimeout);
			if ( status != OK )
				break requestLoop;
			
			do {

				[status, data] = yield AsyncConnectionRead(connection);
				if ( status != OK || !data )
					break requestLoop;
				input.Write(data);
				eoh = input.IndexOf(CRLF+CRLF);
			} while (eoh == -1);

			var [iStatus, iHeaders] = ParseHeaders( input.Read(eoh+4) );

			Print( connection.peerName + ' ' + iStatus.method + ' ' + iStatus.path, '\n' );

			var oStatus = {}, oHeaders = {};
			oHeaders['Date'] = new Date().toUTCString();
			oHeaders['Server'] = _name;
			oHeaders['Expires'] = '0';
			oHeaders['Cache-Control'] = 'no-cache';
			oHeaders['Pragma'] = 'no-cache';

			oStatus.code = 204; // no content
			oStatus.httpVersion = iStatus.httpVersion;
			
			function Respond() {
				
				if ( iStatus.httpVersion >= 1.1 && iHeaders['Connection'] != 'close' && oHeaders['Connection'] != 'close' && remainRequestCount > 0 && (oHeaders['Content-Length'] > 0 || oHeaders['Transfer-Encoding'] == 'chunked') ) {

					oHeaders['Connection'] = 'keep-alive';
					oHeaders['Keep-Alive'] = 'timeout='+(keepAliveTimeout/SECOND).toFixed()+', max='+remainRequestCount;
				} else
					oHeaders['Connection'] = 'close';
				
				SendData( CreateHttpHeaders( oStatus, oHeaders ) );
				return SendData;
			}


			var requestHandler = undefined;
			
			for ( var [pathRegExpr, requestHandlerConstructor] in Iterator(_requestHandlerList) ) {
				
				if ( pathRegExpr(iStatus.path) ) {
				
					requestHandler = new requestHandlerConstructor( iStatus, iHeaders, oStatus, oHeaders, Respond );
					break;
				}
			}


			if ( requestHandler ) {

				switch ( iStatus.method ) {
					case 'GET':
						break;
					case 'POST':
						var iclen = iHeaders.contentlength;
						do {

							if ( input.length < iclen ) {

								[status, data] = yield AsyncConnectionRead(connection);
								if (!data)
									break requestLoop;
								input.Write(data);
							}

							if ( input.length > iclen ) {

								requestHandler.OnData && requestHandler.OnData(input.Read(iclen));
								iclen = 0;
							} else {

								iclen -= input.length;
								requestHandler.OnData && requestHandler.OnData(input.Read());
							}
						} while (iclen);
						break;
				}
				requestHandler.OnEndOfData && requestHandler.OnEndOfData();
			} else {

				var message = 'Unable to handle ' + iStatus.path;
				oStatus.code = 404;
				oHeaders['Content-Length'] = message.length;
				oHeaders['Content-Type'] = 'text/plain';
				var output = Respond();
				output(message);
			}			


		} while ( --remainRequestCount && oHeaders['Connection'] != 'close' );
		connection.Close();
		
		connectionCount--;
	}




	function StartServer() {
	
		serverConnection = new TCPServer( port, undefined, getData($MD.socketBackLog) );
		serverConnection.OnIncoming = function(connection) {

			if ( connectionCount <= getData($MD.maxConnections) ) {
			
				StartAsyncProc( ProcessConnectionProc(connection, getData($MD.connectionKeepAliveMax), getData($MD.connectionKeepAliveTimeout)) );
			} else {	
			
				connection.Close();
				return;
			}

		}
	}
	
	// AddRequestHandler( /s4f5sd/, function
	
	
	var _requestHandlerList = {};
	
	this.moduleApi = {
		
		AddRequestHandler: function( pathRegExpr, requestHandlerConstructor ) {
		
			_requestHandlerList[pathRegExpr] = [pathRegExpr, requestHandlerConstructor];
		},
		
		RemoveRequestListener: function( pathRegExpr ) {
			
			delete _requestHandlerList[pathRegExpr];
		}
	};	
	
	this.stateListener = [
		{
			set: function(s) s[STATE_RUNNING] && s[_name],
			reset: function(s) !s[STATE_RUNNING] || !s[_name],
			trigger: function(polarity) {
			
				if (polarity) {
					
					StartServer();

				} else {

					// kill all consoles
				}
				
			}
		}
	];	

})
