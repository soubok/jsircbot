/* ***** BEGIN LICENSE BLOCK *****
 * Version: GNU GPL 2.0
 *
 * The contents of this file are subject to the
 * GNU General Public License Version 2.0; you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * ***** END LICENSE BLOCK ***** */

(function webConsoleModule($D, $A, $S) {
	
	LoadModule('jsz');
	
	this.disabled = false;
	var _name = this.name = this.constructor.name;
	var $MD = $D[_name];

	var maxConnections = 3;
	var count = 0;
	var serverConnection;
	var port = 80;


	const mimeType = {
		html:'text/html',
		gif:'image/gif',
		jpeg:'image/jpeg',
		jpg:'image/jpeg',
		jpe:'image/jpeg',
		svg:'image/svg+xml'
	};

	const statusText = { 
		200:'OK', 
		404:'Not Found' 
	};

	// Tools

	function MimeTypeByFileName(fileName) {

		return mimeType[fileName.substr(fileName.lastIndexOf(DOT)+1)] || 'text/html; charset=iso-8859-1';
	}

	function NormalizeHeaderName(rawName) {

		return rawName.toLowerCase().split('-').join('');
	}

	function ParseHeaders(buffer) {

//		log.WriteLn(buffer);
		try {
			var lines = buffer.split(CRLF);
			var [method,url,proto] = lines[0].split(SPC);
			var httpVersion = Number(proto.split(SLASH)[1]);
			var [path,query] = url.split('?');
			var status = { method:method, url:url, httpVersion:httpVersion, path:path, query:query };
			var headers = {};
			for ( var i=1; lines[i].length; i++ ) {
				var [name,value] = lines[i].split(':');
				headers[NormalizeHeaderName(name)] = Trim(value);
			}
		} catch(error) {
//			log.WriteLn('Error while parsing headers :\n'+buffer);
			throw new Halt( 'header parsing error (see log file)' );
		}
		return [ status, headers ];
	}

	function CreateHttpHeaders( status, headers ) {

		var buf = 'HTTP/1.1' + SPC + status + SPC + statusText[status] + CRLF;
		for ( var [h,v] in Iterator(headers) )
			buf += h + ': ' + v + CRLF;
		return buf + CRLF;
	}

	
	function Console(output) {
		
		var file = new File('./webConsole.html'); // (TBD) from config
		var template = file.content;
		this.input = function() {
		}
	}




	function NormalizePath( path ) { // (TBD) try with regexp

		var epath = path.split('/');
		var newPath = [];
		for each ( var name in epath )
			switch (name) {
			case '..':
				newPath.pop();
				break;
			case '.':
			case '':
				break;
			default:
				newPath.push(name);
			}
		return newPath.join('/');
	}



	function ProcessRequest( status, headers, output, outputHeaders, close ) {

		var root='./';
		var data = '';

		var file = new File( root + NormalizePath(status.path) );
		if ( !file.exist || file.info.type != File.FILE_FILE ) {

			var message = 'file not found';
			output(CreateHttpHeaders( 404, {'Content-Length':message.length, 'Content-Type':'text/plain'} ));
			output(message);
			return Noop;
		}

		return function(chunk) {

			if ( !chunk ) {
			
				var respondeHeaders = {};
				respondeHeaders['Content-Type'] = MimeTypeByFileName( status.path );

				var useChunksEncoding = false;
				var useKeepAliveConnection = false;


				if (status.httpVersion == 1.1) {
					useKeepAliveConnection = true;
					useChunksEncoding = true;				
				}

				if (useKeepAliveConnection)
					respondeHeaders['Connection'] = 'Keep-Alive';
				
				// Keep-Alive: timeout=15, max=88 ... Keep-Alive: timeout=15, max=87

				if (useChunksEncoding)
					respondeHeaders['Transfer-Encoding'] = 'chunked';


				var SendChunk = Identity;
				var ContentEncoding = Identity;

				if ( headers.acceptencoding && headers.acceptencoding.indexOf('deflate') != -1 ) {

					respondeHeaders['Content-Encoding'] = 'deflate';
					ContentEncoding = new Z(Z.DEFLATE);
				}

				file.Open( File.RDONLY );

				//1
				outputHeaders( 200, respondeHeaders );
				
				//2
				output( function(chunks) {

					var data = file.Read(Z.idealInputLength);

					data = ContentEncoding(data);

					if ( data.length ) {

						if ( useChunksEncoding )
							chunks.push( data.length.toString(16) + CRLF, data, CRLF );
						else
							chunks.push( data );

						return true; // continue
					}
					file.Close();
					return false;
				} );
				
				//3
				if ( useChunksEncoding )
					output( '0' + CRLF + CRLF );

				//4
				if ( !useKeepAliveConnection )
					output(close); // close the socket
			} else {
	
				data += chunk;
			}
		}
	}
	
	
	function ProcessRequestProc(status, headers, asyncBodyRead, outputHeaders, output) {
		
		
		
		
	}
	

	
	function ProcessConnectionProc(connection, maxRequest) {
		
		var input = new Buffer();
		var _output = [];

		function Output( dataInfo ) {

			_output.push(dataInfo);
			while ( _output.length ) {
			
				dataInfo = _output[0];
				if ( dataInfo instanceof Function ) {
					var chunks = [];
					dataInfo(chunks) || _output.shift(); // ''exhausted'' function
					if ( chunks.length == 0 )
						return; // cannot shift here because the next item may be a Function
					_output = chunks.concat(_output);
				}
				connection.Write( _output.shift(), true ); // async write
			}
		}


		requestLoop:
		while (maxRequest--) {

			var data, pr, eoh;

			do {
				[data] = yield AsyncConnectionRead(connection);
				if (!data)
					break requestLoop;
				input.Write(data);
				eoh = input.IndexOf(CRLF+CRLF);
			} while (eoh == -1);

			var [status, headers] = ParseHeaders( input.Read(eoh+4) );
			status.peerName = connection.peerName;

			Print( status.peerName + ' ' + status.method + ' ' + status.path, '\n' );



			function OutputHeaders( oStatus, oHeaders ) {
				
				if ( oHeaders['Connection'] == 'close' )
					maxRequest = 0;
					
				if ( maxRequest == 0 )
					oHeaders['Connection'] = 'close';
				
				Output( CreateHttpHeaders( oStatus, oHeaders ) );
			}
			
			var pr = ProcessRequest( status, headers, Output, OutputHeaders );
			
			switch ( status.method ) {
				case 'GET':
					break;
					
				case 'POST':
					var clen = headers.contentlength;
					do {

						if ( input.length < clen ) {

							[data] = yield AsyncConnectionRead(connection);
							if (!data)
								break requestLoop;
							input.Write(data);
						}

						if ( input.length > clen ) {

							pr(input.Read(clen));
							clen = 0;
						} else {

							clen -= input.length;
							pr(input.Read());
						}
					} while (clen);
					break;
			}
			
			pr(); // eof
		}
		
		connection.Close();
	}




	function StartServer() {
	
		serverConnection = new TCPServer( port, undefined, 3 );
		serverConnection.OnIncoming = function(connection) {

			if ( count > maxConnections ) {
			
				connection.Close();
			} else {
				
				count++;
				StartAsyncProc( ProcessConnectionProc(connection, 3) );
			}
		}
	}
	
	
	this.moduleListener = {
	};
	
	this.moduleApi = {
	};	
	
	this.stateListener = [
		{
			set: function(s) s[STATE_RUNNING] && s[_name],
			reset: function(s) !s[STATE_RUNNING] || !s[_name],
			trigger: function(polarity) {
			
				if (polarity) {
					
					StartServer();

				} else {
					// kill all consoles
				}
				
			}
		}
	];	

})
