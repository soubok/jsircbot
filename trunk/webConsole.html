<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>console</title>
<style type="text/css">

html {
	overflow-x: hidden;
	overflow-y: scroll;
	overflow: -moz-scrollbars-vertical;
}

body {
	margin: 1px;
}

html, #in {
	background-color: black;
	color: #BBB;
	white-space: nowrap;
	font-family: console, monospace;
	font-weight: bold;
	font-size: 10pt;
}


#in {
	border-style: none;
	padding: 0px;
	width: 100%;
}

</style>
<script type="text/javascript">

NewXMLHttpRequest = window.ActiveXObject ? function() { return new ActiveXObject('Microsoft.XMLHTTP') } : function() { return new XMLHttpRequest() };
AddEvent = window.attachEvent ? function( elt, ev, handler ) { elt.attachEvent( 'on'+ev, handler ) } : function( elt, ev, handler ) { elt.addEventListener( ev, handler, false ) };
RemoveEvent = window.detachEvent ? function( elt, ev, handler ) { elt.detachEvent( 'on'+ev, handler ) } : function( elt, ev, handler ) { elt.removeEventListener( ev, handler, false ) };
PreventDefault = function(ev) { ev.preventDefault ? ev.preventDefault() : (ev.returnValue = true) };
StopPropagation = function(ev) { ev.stopPropagation ? ev.stopPropagation() : (ev.cancelBubble = false) };
InsertHtmlBefore = function(elt, html) {
	var tmp = document.createElement('div');
	tmp.innerHTML = html;
	while ( tmp.firstChild )
		elt.parentNode.insertBefore( tmp.firstChild, elt );
}


function HttpRequest() {

	var _this = this;
	var _xhr = new XMLHttpRequest();
	this.Ready = function() {

		return _xhr.readyState == 0 || _xhr.readyState == 4;
	}

	this.Abort = function() {

		if ( this.Ready() )
			return;
		if ( _xhr.abort )
			_xhr.abort();
		else
			_xhr.open( 'GET', 'about:blank', false );
	}

	this.Send = function(url, data) {

		try {
			_xhr.open( data == undefined ? 'GET' : 'POST', url, true );
			_xhr.onreadystatechange = function() {

				try {
					if ( _xhr.readyState != 4 )
						return;
					if ( _xhr.status != 200 )
						throw Error();
					else
						_this.OnResponse && _this.OnResponse(true, _xhr.responseText, _xhr.getResponseHeader('Content-Type'));
				} catch(ex) {

					_this.OnResponse && _this.OnResponse(false);
				}
			}
			_xhr.send(data == undefined ? null : data);
		} catch(ex) {

			_this.OnResponse && _this.OnResponse(false);
		}
	}
}

var _in;

function Cout(html) {

	var htmlElt = document.documentElement;
	var isAtEnd = (htmlElt.scrollTop + htmlElt.clientHeight >= htmlElt.scrollHeight );
	InsertHtmlBefore(_in, html);
	if ( isAtEnd )
		htmlElt.scrollTop = htmlElt.scrollHeight;
}

function Color(msg, color) {

	return '<span style="color:'+(color)+'">'+msg+'</span>';
}

function ProcessResponse(data, type) {

	if ( data )
		switch (type) {
			case 'application/javascript':
			case 'application/x-javascript':
			case 'text/javascript':
				eval(data);
				break;
			case 'text/html':
			case 'text/plain':
				Cout(data);
				break;
			default:
				Cout(Color(data,'gray')+'<br/>');
		}
}

var xhr = new HttpRequest();
xhr.OnResponse = function(status, data, type) {

	if ( status )
		ProcessResponse(data, type);
	else
		Cout(Color('Connection closed<br/>','red'));
}

var pxhr = new HttpRequest();
function StartPendingRequest() {

	pxhr.Send('?action=wait', null);
}
pxhr.OnResponse = function(status, data, type) {

	if ( status ) {
		ProcessResponse(data, type);
		StartPendingRequest();
	} else
		Cout(Color('Connection closed<br/>','red'));
}


var stack = [''], stackp = 0;
function OnKey(event) {

	switch (event.keyCode) {

		case 38: // up
			if ( event.shiftKey || event.ctrlKey || event.altKey )
				return;
			if ( stackp == 0 )
				stack[0] = _in.value;
			if ( stackp < stack.length-1 )
				stackp++;
			_in.value = stack[stackp];
			break;
		case 40: // down
			if ( event.shiftKey || event.ctrlKey || event.altKey )
				return;
			_in.value = stackp ? stack[--stackp] : stack[0];
			break;
		case 13:
			if ( !xhr.Ready() )
				return;
			if ( event.shiftKey || event.ctrlKey || event.altKey )
				return;
			stackp=0;
			stack[0] = _in.value;
			if ( stack[0] == stack[1] )
				stack[0] = '';
			else
				stack.unshift('');
			xhr.Send('?action=submit', _in.value);
			_in.value = '';
			_in.focus();
			break;
		case 27:
			_in.value = stackp ? stack[stackp=0] : '';
			break;
		case 33: // pageup
			if ( event.ctrlKey )
				document.body.scrollTop -= document.body.clientHeight;
			else
				return;
			break;
		case 34: // pagedown
			if ( event.ctrlKey )
				document.body.scrollTop += document.body.clientHeight;
			else
				return;
			break;
		case 35: // end
			if ( event.ctrlKey )
				document.body.scrollTop = document.body.scrollHeight;
			else
				return;
			break;
		case 36: // home
			if ( event.ctrlKey )
				document.body.scrollTop = 0;
			else
				return;
			break;
		default:
			return;
	}
	PreventDefault(event);
	StopPropagation(event);
}


function Init() {

	_in = document.getElementById('in');

//	var x = NewXMLHttpRequest();
//	x.open('GET','?action=history',false);
//	x.send(null);
//	Cout(x.responseText);

	_in.focus();

	StartPendingRequest();
//	window.onbeforeunload = function() { return 'This will close the current session.' };
}
</script>
</head>
<body onload="Init()" onclick="_in.focus()">
<input type="text" id="in" onkeydown="OnKey(event)" autocomplete="off" />
</body>
</html>
