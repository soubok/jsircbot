<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>console</title>
<style type="text/css">
html {
	overflow-x: hidden;
	overflow-y: scroll;
	overflow: -moz-scrollbars-vertical;
}
body {
	margin: 1px;
}
html, #in {
	background-color: black;
	color: #BBB;
	white-space: nowrap;
	font-family: console, monospace;
	font-weight: bold;
	font-size: 10pt;
}
#in {
	border-style: none;
	padding: 0px;
	width: 100%;
}
</style>
<style type="text/css" title="terminal" rel="stylesheet"></style>
<style type="text/css" title="console" rel="alternate stylesheet" disabled="disabled">
body {
	border-bottom: 20px solid black;
}
#in {
	position: fixed;
	bottom: 0px;
	left: 0px;
	border-top: 2px solid #666;
	background-color: #111;
}
</style>
<style id="sty" type="text/css" rel="stylesheet"></style>
<script type="text/javascript">
NewXMLHttpRequest = window.ActiveXObject ? function() { return new ActiveXObject('Microsoft.XMLHTTP') } : function() { return new XMLHttpRequest() };
AddEvent = window.attachEvent ? function( elt, ev, handler ) { elt.attachEvent( 'on'+ev, handler ) } : function( elt, ev, handler ) { elt.addEventListener( ev, handler, false ) };
RemoveEvent = window.detachEvent ? function( elt, ev, handler ) { elt.detachEvent( 'on'+ev, handler ) } : function( elt, ev, handler ) { elt.removeEventListener( ev, handler, false ) };

function PreventDefault(ev) {

	ev.preventDefault ? ev.preventDefault() : (ev.returnValue = true);
}

function StopPropagation(ev) {

	ev.stopPropagation ? ev.stopPropagation() : (ev.cancelBubble = false);
}

function InsertHtmlBefore(elt, html) {

	var tmp = document.createElement('div');
	tmp.innerHTML = html;
	while ( tmp.firstChild )
		elt.parentNode.insertBefore( tmp.firstChild, elt );
}

function SetStyle(style) {

	var e = document.getElementById('sty');
	if ( e.styleSheet ) {
		e.styleSheet.cssText = style;
	} else  {
		for( ;e.firstChild; e.removeChild(e.firstChild));
		e.appendChild(document.createTextNode(style)); // || firefox: e.innerHTML = style;
	}
}

function HttpRequest() {

	var _this = this;
	var _xhr = new XMLHttpRequest();
	this.Ready = function() {

		return _xhr.readyState == 0 || _xhr.readyState == 4;
	}

	this.Abort = function() {

		if ( this.Ready() )
			return;
		if ( 'abort' in _xhr )
			_xhr.abort();
		else
			_xhr.open( 'GET', 'about:blank', false );
	}

	this.Send = function(url, data, sync) {

		try {
			_xhr.open( data == undefined ? 'GET' : 'POST', url, !sync );

			if ( !sync ) {
				_xhr.onreadystatechange = function() {

					try {
						if ( _xhr.readyState != 4 )
							return;
						if ( _xhr.status != 200 )
							throw Error();
						else
							_this.OnResponse && _this.OnResponse(true, _xhr.responseText, _xhr.getResponseHeader('Content-Type'));
					} catch(ex) { _this.OnResponse && _this.OnResponse(false) }
				}
			}
			_xhr.send(data == undefined ? null : data);
			if ( sync && _xhr.status == 200 )
				return _xhr.responseText;

		} catch(ex) { _this.OnResponse && _this.OnResponse(false) }
	}
}

var _in;

function Cout(html) {

	var htmlElt = document.documentElement;
	var isAtEnd = (htmlElt.scrollTop + htmlElt.clientHeight >= htmlElt.scrollHeight - 1); // cf. body {	margin: ...
	InsertHtmlBefore(_in, html);
	if ( isAtEnd )
		htmlElt.scrollTop = htmlElt.scrollHeight;
}

function Color(msg, color) {

	return '<span style="color:'+(color)+'">'+msg+'</span>';
}

function ProcessResponse(data, type) {

	if ( data )
		switch (type) {
			case 'application/javascript':
			case 'application/x-javascript':
			case 'text/javascript':
				eval(data);
				break;
			case 'text/css':
				SetStyle(data);
				break;
			case 'text/html':
			case 'text/plain':
				Cout(data);
				break;
			case 'text/json':
				var itemList;
				try {
					itemList = eval('('+data+')');
				} catch(ex) {}
				for ( var i in itemList )
					ProcessResponse(itemList[i][0], itemList[i][1])
				break;
			default:
				Cout(Color(data,'gray')+'<br/>');
		}
}

var xhr = new HttpRequest();
var pxhr = new HttpRequest();

xhr.OnResponse = function(status, data, type) {

	if ( status )
		ProcessResponse(data, type);
	else
		Cout(Color('Connection closed<br/>','red'));
}

function StartPendingRequest() {

	pxhr.Send('?action=wait', null);
}

pxhr.OnResponse = function(status, data, type) {

	if ( status ) {
		ProcessResponse(data, type);
		StartPendingRequest();
	} else
		Cout(Color('Connection closed<br/>','red'));
}


var stack = [''], stackp = 0;
function OnKey(event) {

	switch (event.keyCode) {

		case 38: // up
			if ( event.shiftKey || event.ctrlKey || event.altKey )
				return;
			if ( stackp == 0 )
				stack[0] = _in.value;
			if ( stackp < stack.length-1 )
				stackp++;
			_in.value = stack[stackp];
			break;
		case 40: // down
			if ( event.shiftKey || event.ctrlKey || event.altKey )
				return;
			_in.value = stackp ? stack[--stackp] : stack[0];
			break;
		case 13:
			if ( !xhr.Ready() )
				return;
			if ( event.shiftKey || event.ctrlKey || event.altKey )
				return;
			stackp=0;
			stack[0] = _in.value;
			if ( stack[0] == stack[1] )
				stack[0] = '';
			else
				stack.unshift('');
			xhr.Send('?action=submit', _in.value);
			_in.value = '';
			_in.focus();
			break;
		case 27:
			_in.value = stackp ? stack[stackp=0] : '';
			break;
		case 33: // pageup
			if ( event.ctrlKey )
				document.body.scrollTop -= document.body.clientHeight;
			else
				return;
			break;
		case 34: // pagedown
			if ( event.ctrlKey )
				document.body.scrollTop += document.body.clientHeight;
			else
				return;
			break;
		case 35: // end
			if ( event.ctrlKey )
				document.body.scrollTop = document.body.scrollHeight;
			else
				return;
			break;
		case 36: // home
			if ( event.ctrlKey )
				document.body.scrollTop = 0;
			else
				return;
			break;
		default:
			return;
	}
	PreventDefault(event);
	StopPropagation(event);
}


function Init() {

	_in = document.getElementById('in');
	ProcessResponse( new HttpRequest().Send('?action=history', undefined, true) , 'text/json');
	_in.focus();
	StartPendingRequest();
//	window.onbeforeunload = function() { return 'This will close the current session.' };
}
</script>
</head><body onload="Init()" onclick="_in.focus()" onfocus="_in.focus()" onresize="with(document.documentElement) scrollTop=scrollHeight"><input type="text" id="in" onkeydown="OnKey(event)" autocomplete="off" /></body>
</html>
