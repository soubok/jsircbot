/* ***** BEGIN LICENSE BLOCK *****
 * Version: GNU GPL 2.0
 *
 * The contents of this file are subject to the
 * GNU General Public License Version 2.0; you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * ***** END LICENSE BLOCK ***** */

(function webServerModule($D, $A, $S) {
	
	LoadModule('jsz');
	
	this.disabled = false;
	var _name = this.name = this.constructor.name;
	var $MD = $D[_name];

	const mimeType = {
		htm:'text/html',
		html:'text/html',
		xml:'text/xml',
		gif:'image/gif',
		jpeg:'image/jpeg',
		jpg:'image/jpeg',
		jpe:'image/jpeg',
		svg:'image/svg+xml'
	};

	const reasonPhrase = {
		100: 'Continue',
		101: 'Switching Protocols',
		
		200: 'OK',
		201: 'Created',
		202: 'Accepted',
		203: 'Non-Authoritative Information',
		204: 'No Content',
		205: 'Reset Content',
		206: 'Partial Content',
		
		300: 'Multiple Choices',
		301: 'Moved Permanently',
		302: 'Found',
		303: 'See Other',
		304: 'Not Modified',
		305: 'Use Proxy',
		307: 'Temporary Redirect',
		
		400: 'Bad Request',
		401: 'Unauthorized',
		402: 'Payment Required',
		403: 'Forbidden',
		404: 'Not Found',
		405: 'Method Not Allowed',
		406: 'Not Acceptable',
		407: 'Proxy Authentication Required',
		408: 'Request Time-out',
		409: 'Conflict',
		410: 'Gone',
		411: 'Length Required',
		412: 'Precondition Failed',
		413: 'Request Entity Too Large',
		414: 'Request-URI Too Large',
		415: 'Unsupported Media Type',
		416: 'Requested range not satisfiable',
		417: 'Expectation Failed',
		
		500: 'Internal Server Error',
		501: 'Not Implemented',
		502: 'Bad Gateway',
		503: 'Service Unavailable',
		504: 'Gateway Time-out',
		505: 'HTTP Version not supported'
	};


	// Tools

	function MimeTypeByFileName(fileName) {

		return mimeType[fileName.substr(fileName.lastIndexOf(DOT)+1)] || 'text/html; charset=iso-8859-1';
	}

	function NormalizeHeaderName(rawName) {
		
		return [ h[0].toUpperCase()+h.substr(1) for each( h in rawName.split('-')) ].join('-');
	}

	function ParseHttpStatus(buffer) {
		
		var status = {};
		status.method = buffer.ReadUntil(SPC);
		status.url = buffer.ReadUntil(SPC);
		status.protoName = buffer.ReadUntil(SLASH);
		status.protoVersion = buffer.ReadUntil(CRLF);
		var [path,query] = status.url.split('?');
		status.path = path;
		status.query = query;
		return status;
	}
	
	function ParseHttpHeaders(buffer) {

		var headers = new HttpHeaders();
		for (;;) {
			var key = buffer.ReadUntil(': ');
			var value = buffer.ReadUntil(CRLF);
			if ( !key )
				break;
			headers.Set(key, value);
		}
		return headers;
	}

	function HttpHeaders() {

		var _headers = {};		
		this.Parse = function(rawHeaders) {
			
			var hre = /(.*?): ?(.*?)\r?\n/g;
			var res;
			for ( hre.lastIndex = 0; res = hre.exec(rawHeaders); _headers[res[1]] = res[2]);
		}
		this.Has = function(name) {
			
			return name in _headers;
		}
		this.Set = function(name, value) {
			
			_headers[name] = value;
		}
		this.MSet = function(obj) {
			
			for ( var p in obj )
				_headers[p] = obj[p];
		}
		this.Get = function(name) {
			
			return _headers[name];
		}
		this.Is = function(name, value) {
			
			return name in _headers && _headers[name].toLowerCase() == value.toLowerCase();
		}
		this.Serialize = function() {
			
			var tmp = '';
			for ( var [h,v] in Iterator(_headers) )
				tmp += h + ': ' + v + CRLF;
			return tmp;
		}
	}



	function CreateHttpHeaders( statusCode, protoVersion, headers ) {

		var buf = 'HTTP/' + protoVersion + SPC + statusCode + SPC + reasonPhrase[statusCode] + CRLF;
		return buf + headers.Serialize() + CRLF;
	}

	
	function ParseQueryData(str) {
		
		var map = {};
		if ( str )
			for each ( var p in str.split('&') )
				let ( [key, val] = p.split('=') ) // report a "strict warning: reference to undefined property 1" because 'foo'.split('=') do not have a [1]
					map[key] = val;
		return map;
	}
	
	function ParseCookieData(str) {
		
		var map = {};
		if ( str )
			for each ( var p in str.split('; ') )
				let ( [key, val] = p.split('=') )
					map[key] = val;
		return map;
	}
	
	function SaveData(name, data) {

		var expires = new Date;
		expires.setDate(expires.getDate() + 365); // espires in 1 year
		document.cookie = name + "=" + encodeURIComponent(data) + ";expires=" + expires.toGMTString();
	}


	function LoadData(name) {

		 if (document.cookie.length) {

			  var start = document.cookie.indexOf(name + "=");
			  if (start != -1) {

					start = start + name.length + 1;
					var end = document.cookie.indexOf(";", start);
					if (end == -1)
						 end = document.cookie.length;
					return decodeURIComponent(document.cookie.substring(start, end));
			  }
		 }
		 return "";
	}	


	function NormalizePath( path ) { // (TBD) try with regexp

		var epath = path.split('/');
		var newPath = [];
		for each ( var name in epath )
			switch (name) {
			case '..':
				newPath.pop();
				break;
			case '.':
			case '':
				break;
			default:
				newPath.push(name);
			}
		return newPath.join('/');
	}



	function ProcessFileRequest( iStatus, iHeaders, oHeaders, Respond ) {

		var root='./';
		var data = '';
		
		var fileName = root + NormalizePath(iStatus.path);
		var file = new File( fileName );
		if ( !file.exist || file.info.type != File.FILE_FILE ) {

			var message = 'file '+fileName+' not found';
			oHeaders.Set('Content-Length', message.length);
			oHeaders.Set('Content-Type', 'text/plain');
			Respond(404)(message);
			return;
		}
		
		this.OnBodyData = function(buf) data += buf;

		this.OnEndOfBody = function() {

			oHeaders.Set('Content-Type', MimeTypeByFileName(fileName));

			var useChunksEncoding = false;
			if (iStatus.protoVersion >= 1.1) {
			
				useChunksEncoding = true;				
				oHeaders.Set('Transfer-Encoding', 'chunked');
			}

			var ContentEncoding = Identity;
			if ( iHeaders.Has('Accept-Encoding') && iHeaders.Get('Accept-Encoding').indexOf('deflate') != -1 ) {

				oHeaders.Set('Content-Encoding', 'deflate');
				ContentEncoding = new Z(Z.DEFLATE);
			}

			file.Open( File.RDONLY );
			Respond(200)( function() {

				var data = file.Read(Z.idealInputLength);
				if ( data.length ) {

					data = ContentEncoding(data);
					if ( useChunksEncoding )
						return [ data.length.toString(16) + CRLF, data, CRLF ];
					else
						return [ data ];
				}
				file.Close();
				return false;
			} );
			if ( useChunksEncoding )
				res( '0' + CRLF + CRLF );
		}
	}

	
	
	function ConsoleSession() {
		
		var _this = this;
		
		
		io.AddTimeout( 1000, function() { 
			_this.Send('123<br/>');
			io.AddTimeout( 1000, arguments.callee );
		});
		
		
		this.Request = function(data) {
			
			this.Send('>>> '+data+'<br/>');
		}
		
	}

	
	
	var _consoles = {};
	
	function ProcessConsoleAccess(req) {

		var query = ParseQueryData(req.iStatus.query);
		var cookie = ParseCookieData(req.iHeaders.Get('Cookie'));
		var sid = cookie.sid;
		var action = query.action;

		var console = _consoles[sid];

		if ( !action ) {
		
			let sid = RandomString(32);
			_consoles[sid] = console = new ConsoleSession(); // (TBD) remove it !
			console.pendingMessagesQueue = [];
			console.Send = function(data) void console.pendingMessagesQueue.push(data);
			
//			io.RemoveTimeout(console.timeout);
//			console.timeout = io.AddTimeout( getData($MD.consoleSessionTimeout), function() delete onsoles[sid] );
			
//			sessionTimeout && io.RemoveTimeout(sessionTimeout);
//			sessionTimeout = io.AddTimeout( getData($MD.consoleSessionTimeout), KillConsoleSession );

			let content = new File('./webConsole.html').content; // (TBD) filename from config
			req.oHeaders.Set('Content-Length', content.length);
			req.oHeaders.Set('Set-Cookie', 'sid='+sid+'; path='+req.iStatus.path); // Set-Cookie: <name>=<value>[; <name>=<value>]... [; expires=<date>][; domain=<domain_name>][; path=<some_path>][; secure][; httponly]
			req.Respond(200);
			req.Send(content);
			req.End();
			return;
		}
		
		if ( !console ) {
			
			let message = '<span style="color:red">Invalid session.</span><br/>';
			req.oHeaders.Set('Content-Length', message.length);
			req.oHeaders.Set('Connection', 'close'); // needed to ignore request body !! else, we need to read it !
			req.Respond(404);
			req.Send(message);
			req.End();
			return;
		}


		if ( action == 'wait' ) {
			
			if ( console.pendingMessagesQueue.length ) {
				
				let data = console.pendingMessagesQueue.join('');
				console.pendingMessagesQueue.splice(0);
				req.oHeaders.Set('Content-Length', data.length);
				req.Respond(200);
				req.Send(data);
				req.End();
				console.Send = function(data) console.pendingMessagesQueue.push(data);
			
			} else {
			
				console.Send = function(data) {

					if ( req.Respond ) {

						req.oHeaders.Set('Content-Length', data.length);
						req.Respond(200);
						req.Send(data);
						req.End();
					} else {

						console.pendingMessagesQueue.push(data);
					}
				}
			}
			return;
		} 


		if ( action == 'submit' ) {
			
			var consData = '';
			req.OnBodyData = function(buf) consData += buf;
			req.OnEndOfBody = function() {

				let prevSend = console.Send;
				
				console.Send = function(data) void console.pendingMessagesQueue.push(data);
				console.Request(consData);
				let data = console.pendingMessagesQueue.join('');
				console.pendingMessagesQueue.splice(0);
				req.oHeaders.Set('Content-Length', data.length);
				req.Respond(200);
				req.Send(data);
				req.End();
				console.Send = prevSend;
			}
			return;
		}
	}





	var _requestHandlerList = {};
	
	function FindRequestHandler(path) {
		
		for each ( var [match, requestHandler] in _requestHandlerList )
			if ( match(path) )
				return requestHandler;
		return undefined;
	}
	
	var totalConnectionCount = 0;

	function HttpConnection(connection, remainRequestCount, keepAliveTimeout) {
		
		var input = new Buffer();
		var connectionDataRate = new SingleRateMeter(getData($MD.connectionDataRate));
		var timeout;
		var req;
		var OnData;
		
		totalConnectionCount++;

		function ResetTimeout() {
			
			timeout && io.RemoveTimeout(timeout);
			timeout = io.AddTimeout( keepAliveTimeout, function() connection.Write( function() void connection.Disconnect(), true ) );
		}

		ResetTimeout();
		
		connection.OnData = function() {

			var data = connection.Read();
			input.Write(data);
			if ( !connectionDataRate.Inc(data.length) )
				connection.Sleep( connectionDataRate.RestTime() );
			OnData();
		}
			
		connection.OnDisconnected = function(c) { // OnFailed ?
			
			io.RemoveTimeout(timeout);
			req.OnDisconnected && req.OnDisconnected();
			totalConnectionCount--;
			req.Close();
		}

		function Request(iStatus, iHeaders) {

			this.iStatus = iStatus;
			this.iHeaders = iHeaders;
			this.oHeaders = new HttpHeaders();
			this.OnBodyData = Noop;
			this.OnEndOfBody = Noop;
			this.OnDisconnected = Noop;

			this.Close = function() {
				
				delete this.Respond;
				delete this.Send;
				delete this.End;
				req.OnBodyData = Noop;
				req.OnEndOfBody = Noop;
			}
		
			this.Send = function(item) connection.Write(item, true); // (TBD) contextual send that manages chunks
			
			this.Respond = function(statusCode, protoVersion) {
			
				statusCode = statusCode || 200;
				protoVersion = protoVersion || this.iStatus.protoVersion;
				protoVersion > this.iStatus.protoVersion && ReportFailure('HTTP version too high ('+protoVersion+')');
				if ( this.iStatus.protoVersion >= 1.1 && this.iHeaders.Is('Connection', 'keep-alive') && !this.oHeaders.Is('Connection', 'close') && remainRequestCount > 0 && (this.oHeaders.Has('Content-Length') || this.oHeaders.Is('Transfer-Encoding', 'chunked')) ) {

					this.oHeaders.Set('Connection', 'keep-klive' );
					this.oHeaders.Set('Keep-Alive', 'timeout='+(keepAliveTimeout/SECOND).toFixed()+', max='+remainRequestCount );
				} else {
					this.oHeaders.Set('Connection', 'close');
				}
				this.Send( CreateHttpHeaders( statusCode, protoVersion, this.oHeaders ) );
			}
			
			this.End = function() {
				
				this.end = true;
				
				if ( this.oHeaders.Is('Connection', 'close') ) {
					
					connection.Write(function() void connection.Disconnect(), true);
					req.Close();
					OnData = Noop;
				} else { // we must read the whole body before getting the next request
					
					req.OnBodyData = Noop;
					req.OnEndOfBody = Noop;
				}
			}
		}

		ProcessHttpHeader();

		
		function ProcessHttpHeader() {
			
			OnData = arguments.callee;
			if ( input.IndexOf(CRLF+CRLF) == -1 )
				return;
			
			ResetTimeout();
			remainRequestCount--;

			req = new Request(ParseHttpStatus(input), ParseHttpHeaders(input));
			req.oHeaders.MSet({ 'Date':new Date().toUTCString(), 'Server':_name, 'Expires':'0', 'Cache-Control':'no-cache', 'Pragma':'no-cache', 'Content-Type':'text/html' }); // beware: do not set 'Connection' or 'Content-Length'
			
			EndOfRequest = Noop;
			req.iclen = req.iHeaders.Get('Content-Length');
			

			Print( connection.peerName + ' ' + req.iStatus.method + ' ' + req.iStatus.path + ' ' + req.iStatus.query, '\n' );

			var requestHandler = FindRequestHandler(req.iStatus.path);
			if ( !requestHandler ) {

				var message = 'Unable to handle ' + req.iStatus.path;
				req.oHeaders.MSet({'Content-Length':message.length, 'Content-Type':'text/plain', 'Connection':'close'});
				req.Respond(200);
				req.Send(message);
				req.End();
				return;
			}
			requestHandler(req);
			ProcessHttpBody();
		}
		
		function ProcessHttpBody() {
			
			OnData = arguments.callee;
			if ( !input.length )
				return;
			
			if ( input.length >= req.iclen ) {

				req.OnBodyData(input.Read(req.iclen));
				req.iclen = 0;
			} else {
				req.iclen -= input.length;
				req.OnBodyData(input.Read(req.iclen));
			}
			if ( !req.iclen ) {

				req.OnEndOfBody();

???

				
			}
		}
		
	}




	function StartServer() {

		var incomingConnectionRatePerPeer = new MultiRateMeter(getData($MD.incomingConnectionRatePerPeer));
		
		var serverConnection = new TCPServer( getData($MD.port), getData($MD.bind), getData($MD.socketBackLog) );
		serverConnection.OnIncoming = function(connection) {
			
			if ( totalConnectionCount > getData($MD.maxConnections) || !incomingConnectionRatePerPeer.Inc(connection.peerName, 1) ) {
				
				connection.Close();
				return;
			}

//			StartAsyncProc( ProcessConnectionProc(connection, getData($MD.connectionKeepAliveMax), getData($MD.connectionKeepAliveTimeout)) );
			new HttpConnection(connection, getData($MD.connectionKeepAliveMax), getData($MD.connectionKeepAliveTimeout));
		}
	}
	
	this.moduleApi = {
		
		AddRequestHandler: function( pathRegExpr, requestHandlerConstructor ) _requestHandlerList[String(pathRegExpr)] = [pathRegExpr, requestHandlerConstructor],
		RemoveRequestListener: function( pathRegExpr ) delete _requestHandlerList[String(pathRegExpr)]
	};
	
	
	
	
	this.stateListener = [
		{
			set: function(s) s[STATE_RUNNING] && s[_name],
			reset: function(s) !s[STATE_RUNNING] || !s[_name],
			trigger: function(polarity) {
			
				if (polarity) {
					
					StartServer();
//					$A.AddRequestHandler( /^\/dccFiles\//, ProcessFileRequest );
					$A.AddRequestHandler( /^\/cons/, ProcessConsoleAccess );
				} else {

					// kill all consoles
				}
				
			}
		}
	];	

})
