/* ***** BEGIN LICENSE BLOCK *****
 * Version: GNU GPL 2.0
 *
 * The contents of this file are subject to the
 * GNU General Public License Version 2.0; you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * ***** END LICENSE BLOCK ***** */

(function webServerModule($D, $A, $S) {
	
	LoadModule('jsz');
	
	this.disabled = false;
	var _name = this.name = this.constructor.name;
	var $MD = $D[_name];

	const mimeType = {
		htm:'text/html',
		html:'text/html',
		xml:'text/xml',
		gif:'image/gif',
		jpeg:'image/jpeg',
		jpg:'image/jpeg',
		jpe:'image/jpeg',
		svg:'image/svg+xml'
	};

	const reasonPhrase = {
		100: 'Continue',
		101: 'Switching Protocols',
		
		200: 'OK',
		201: 'Created',
		202: 'Accepted',
		203: 'Non-Authoritative Information',
		204: 'No Content',
		205: 'Reset Content',
		206: 'Partial Content',
		
		300: 'Multiple Choices',
		301: 'Moved Permanently',
		302: 'Found',
		303: 'See Other',
		304: 'Not Modified',
		305: 'Use Proxy',
		307: 'Temporary Redirect',
		
		400: 'Bad Request',
		401: 'Unauthorized',
		402: 'Payment Required',
		403: 'Forbidden',
		404: 'Not Found',
		405: 'Method Not Allowed',
		406: 'Not Acceptable',
		407: 'Proxy Authentication Required',
		408: 'Request Time-out',
		409: 'Conflict',
		410: 'Gone',
		411: 'Length Required',
		412: 'Precondition Failed',
		413: 'Request Entity Too Large',
		414: 'Request-URI Too Large',
		415: 'Unsupported Media Type',
		416: 'Requested range not satisfiable',
		417: 'Expectation Failed',
		
		500: 'Internal Server Error',
		501: 'Not Implemented',
		502: 'Bad Gateway',
		503: 'Service Unavailable',
		504: 'Gateway Time-out',
		505: 'HTTP Version not supported'
	};


	// Tools

	function MimeTypeByFileName(fileName) {

		return mimeType[fileName.substr(fileName.lastIndexOf(DOT)+1)] || 'text/html; charset=iso-8859-1';
	}

	function NormalizeHeaderName(rawName) {
		
		return [ h[0].toUpperCase()+h.substr(1) for each( h in rawName.split('-')) ].join('-');
	}

	function ParseHttpStatus(buffer) {
		
		var status = {};
		status.method = buffer.ReadUntil(SPC);
		status.url = buffer.ReadUntil(SPC);
		status.protoName = buffer.ReadUntil(SLASH);
		status.protoVersion = buffer.ReadUntil(CRLF);
		var [path,query] = status.url.split('?');
		status.path = path;
		status.query = query;
		return status;
	}
	
	function ParseHttpHeaders(buffer) {

		var headers = new HttpHeaders();
		for (;;) {
			var key = buffer.ReadUntil(': ');
			var value = buffer.ReadUntil(CRLF);
			if ( !key )
				break;
			headers.Set(key, value);
		}
		return headers;
	}

	function HttpHeaders() {

		var _headers = {};		
		this.Parse = function(rawHeaders) {
			
			var hre = /(.*?): ?(.*?)\r?\n/g;
			var res;
			for ( hre.lastIndex = 0; res = hre.exec(rawHeaders); _headers[res[1]] = res[2]);
		}
		this.Has = function(name) {
			
			return name in _headers;
		}
		this.Set = function(name, value) {
			
			_headers[name] = value;
		}
		this.Get = function(name) {
			
			return _headers[name];
		}
		this.Is = function(name, value) {
			
			return name in _headers && _headers[name].toLowerCase() == value.toLowerCase();
		}
		this.Serialize = function() {
			
			var tmp = '';
			for ( var [h,v] in Iterator(_headers) )
				tmp += h + ': ' + v + CRLF;
			return tmp;
		}
	}



	function CreateHttpHeaders( statusCode, protoVersion, headers ) {

		var buf = 'HTTP/' + protoVersion + SPC + statusCode + SPC + reasonPhrase[statusCode] + CRLF;
		return buf + headers.Serialize() + CRLF;
	}

	
	function ParseQueryData(str) {
		
		var map = {};
		if ( str )
			for each ( var p in str.split('&') )
				let ( [key, val] = p.split('=') ) // report a "strict warning: reference to undefined property 1" because 'foo'.split('=') do not have a [1]
					map[key] = val;
		return map;
	}
	
	function ParseCookieData(str) {
		
		var map = {};
		if ( str )
			for each ( var p in str.split('; ') )
				let ( [key, val] = p.split('=') )
					map[key] = val;
		return map;
	}
	
	function SaveData(name, data) {

		var expires = new Date;
		expires.setDate(expires.getDate() + 365); // espires in 1 year
		document.cookie = name + "=" + encodeURIComponent(data) + ";expires=" + expires.toGMTString();
	}


	function LoadData(name) {

		 if (document.cookie.length) {

			  var start = document.cookie.indexOf(name + "=");
			  if (start != -1) {

					start = start + name.length + 1;
					var end = document.cookie.indexOf(";", start);
					if (end == -1)
						 end = document.cookie.length;
					return decodeURIComponent(document.cookie.substring(start, end));
			  }
		 }
		 return "";
	}	


	function NormalizePath( path ) { // (TBD) try with regexp

		var epath = path.split('/');
		var newPath = [];
		for each ( var name in epath )
			switch (name) {
			case '..':
				newPath.pop();
				break;
			case '.':
			case '':
				break;
			default:
				newPath.push(name);
			}
		return newPath.join('/');
	}



	function ProcessFileRequest( iStatus, iHeaders, oHeaders, Respond ) {

		var root='./';
		var data = '';
		
		var fileName = root + NormalizePath(iStatus.path);
		var file = new File( fileName );
		if ( !file.exist || file.info.type != File.FILE_FILE ) {

			var message = 'file '+fileName+' not found';
			oHeaders.Set('Content-Length', message.length);
			oHeaders.Set('Content-Type', 'text/plain');
			Respond(404)(message);
			return;
		}
		
		this.OnBodyData = function(buf) data += buf;

		this.OnEndOfBody = function() {

			oHeaders.Set('Content-Type', MimeTypeByFileName(fileName));

			var useChunksEncoding = false;
			if (iStatus.protoVersion >= 1.1) {
			
				useChunksEncoding = true;				
				oHeaders.Set('Transfer-Encoding', 'chunked');
			}

			var ContentEncoding = Identity;
			if ( iHeaders.Has('Accept-Encoding') && iHeaders.Get('Accept-Encoding').indexOf('deflate') != -1 ) {

				oHeaders.Set('Content-Encoding', 'deflate');
				ContentEncoding = new Z(Z.DEFLATE);
			}

			file.Open( File.RDONLY );
			Respond(200)( function() {

				var data = file.Read(Z.idealInputLength);
				if ( data.length ) {

					data = ContentEncoding(data);
					if ( useChunksEncoding )
						return [ data.length.toString(16) + CRLF, data, CRLF ];
					else
						return [ data ];
				}
				file.Close();
				return false;
			} );
			if ( useChunksEncoding )
				res( '0' + CRLF + CRLF );
		}
	}

	
	
/*	
	function ConsoleSession() {
		
		var _this = this;
		var _sid = RandomString(32);
		var _pendingMessagesQueue = [];
		
		this.Sid = function() _sid;
		var sessionTimeout;
		
		function KillConsoleSession() {
		
		
		}
		
		function ResetSessionTimeout() {
			
			sessionTimeout && io.RemoveTimeout(sessionTimeout);
			sessionTimeout = io.AddTimeout( getData($MD.consoleSessionTimeout), KillConsoleSession );
		}
		
		this.IncomingMessage = function(data) {
		
		}
		
		
		function SendToQueue(data) {
		
			_pendingMessagesQueue.push(data);
		}
		
		this.IncomingWaitRequest( Respond ) {
			
			_this.Send = function(data) {

				var remain = Send(data);
				if ( !remain )
					return;
				_pendingMessagesQueue.push(remain);
				_this.Send = SendToQueue;
			}

			if ( _pendingMessagesQueue.length )
				_this.Send( _pendingMessagesQueue.join('');
		}
	}
*/	
	
	
	var _consoles = {};
	
	function ProcessConsoleAccess( iStatus, iHeaders, oHeaders, Respond, EndOfResponse ) {

		var query = ParseQueryData(iStatus.query);
		var cookie = ParseCookieData(iHeaders.Get('Cookie'));

		var sid = cookie.sid;
		var action = query.action;
		
		if ( !action ) {

			let content = new File('./webConsole.html').content; // (TBD) filename from config
			oHeaders.Set('Content-Length', content.length);

			var console = new ConsoleSession();
			_consoles[cons.Sid()] = console; // (TBD) remove it !
			

			let sid = RandomString(32);
			_consoles[sid] = { 
				sid: sid,
				count: 0,
				pendingMessages: [],
				WriteToConsole: function(data) {
				
					oHeaders.Set('Content-Length', data.length);
					var remain = Respond(200)(data);
					remain && pendingMessages.push(remain);
				}
			};
			
			oHeaders.Set('Set-Cookie', 'sid='+sid+'; path='+iStatus.path);// Set-Cookie: <name>=<value>[; <name>=<value>]... [; expires=<date>][; domain=<domain_name>][; path=<some_path>][; secure][; httponly]
			Respond(200)(content);
			return;
		}
		
		if ( action == 'wait' && sid in _consoles ) {

			function WriteData(data) {

				oHeaders.Set('Content-Length', data.length);
				var status = Respond(200)(data);
				if ( status != OK )
					pendingMessages.push(data);
			}
			

			if ( pendingMessages.length )
				WriteData( pendingMessages.join('') );

			_consoles[sid].Write = WriteData;
			
			io.AddTimeout( 2000, function() { _consoles[sid].Write('test<br/>') });
			return;
		} 

		if ( action != 'submit' ) {
			
			Respond(204);
			return;
		}
			
		var consData = '';
		this.OnBodyData = function(buf) consData += buf;
		
		this.OnEndOfBody = function() {
			
			let message;
			if ( sid in _consoles ) {

				message = String(_consoles[sid].count);
				message += ' '+consData + '<br>';
			} else {
				
				message = '<span style="color:red">Invalid session.</span><br/>';
			}

			oHeaders.Set('Content-Length', message.length);
			Respond(200)(message);
		}	
	}


	var _requestHandlerList = {};

	var totalConnectionCount = 0;
/*
	function ProcessConnectionProc(connection, remainRequestCount, keepAliveTimeout) { // this async procedure manages the lifetime of an HTTP connection

		totalConnectionCount++;
		var input = new Buffer();
		var SendData = function(data) {
			
			connection.Write(data, true);
			return OK;
		}

		var connectionDataRate = new SingleRateMeter(getData($MD.connectionDataRate));
		
		try {

			do {

				var status, data, pr;

				[status] = yield AsyncConnectionWaitData(connection, keepAliveTimeout);
				if ( status != OK ) // TIMEOUT || DISCONNECTED
					AbortAsyncProc();
				do {

					[status, data] = yield AsyncConnectionRead(connection);
					if ( status != OK || !data || input.length > 8192 )
						AbortAsyncProc();
					input.Write(data);
				} while (input.IndexOf(CRLF+CRLF) == -1);

				if ( !connectionDataRate.Inc(input.length) )
					yield AsyncSleep( connectionDataRate.RestTime() );
					
				var iStatus = ParseHttpStatus( input );
				var iHeaders = ParseHttpHeaders( input );
				
				ReportNotice( connection.peerName + ' ' + iStatus.method + ' ' + iStatus.path + ' ' + iStatus.query, '\n' );
				
				var oHeaders = new HttpHeaders();
				oHeaders.Set( 'Date', new Date().toUTCString() );
				oHeaders.Set( 'Server', _name );
				oHeaders.Set( 'Expires', '0' );
				oHeaders.Set( 'Cache-Control', 'no-cache' );
				oHeaders.Set( 'Pragma', 'no-cache' );
				oHeaders.Set( 'Content-Type', 'text/html' );
				// beware: do not set 'Connection' or 'Content-Length'
				
				function Respond(statusCode, protoVersion) {
					
					statusCode = statusCode || 200;
					protoVersion = protoVersion || iStatus.protoVersion;
					protoVersion > iStatus.protoVersion && ReportFailure('HTTP version too high ('+protoVersion+')');

					if ( iStatus.protoVersion >= 1.1 && iHeaders.Is('Connection', 'keep-alive') && !oHeaders.Is('Connection', 'close') && remainRequestCount > 0 && (oHeaders.Has('Content-Length') || oHeaders.Is('Transfer-Encoding', 'chunked')) ) {

						oHeaders.Set('Connection', 'keep-klive' );
						oHeaders.Set('Keep-Alive', 'timeout='+(keepAliveTimeout/SECOND).toFixed()+', max='+remainRequestCount );
					} else {
						oHeaders.Set('Connection', 'close');
					}
					
					SendData( CreateHttpHeaders( statusCode, protoVersion, oHeaders ), true); // true for async
					
					return function(data) SendData(data);
				}

				var requestHandler = undefined;
				for each ( let [pathRegExpr, requestHandlerConstructor] in _requestHandlerList ) {

					if ( !pathRegExpr(iStatus.path) )
						continue;
					requestHandler = new requestHandlerConstructor( iStatus, iHeaders, oHeaders, Respond );
					break;
				}

				if ( requestHandler ) {

					switch ( iStatus.method.toUpperCase() ) {
						case 'GET':
							break;
						case 'POST':
							var iclen = iHeaders.Get('Content-Length');
							do {

								if ( input.length < iclen ) {

									[status, data] = yield AsyncConnectionRead(connection);
									if (status != OK || !data)
										AbortAsyncProc();

									if ( !connectionDataRate.Inc(data.length) )
										yield AsyncSleep( connectionDataRate.RestTime() );

									input.Write(data);
								}

								if ( input.length >= iclen ) {

									requestHandler.OnBodyData && requestHandler.OnBodyData(input.Read(iclen));
									iclen = 0;
								} else {

									iclen -= input.length;
									requestHandler.OnBodyData && requestHandler.OnBodyData(input.Read());
								}
							} while (iclen);
							break;
						default:
							ReportWarning('...Unable to manage this request.');
							Respond(204);
					}
					requestHandler.OnEndOfBody && requestHandler.OnEndOfBody();
				} else {

					var message = 'Unable to handle ' + iStatus.path;
					oHeaders.Set('Content-Length', message.length);
					oHeaders.Set('Content-Type', 'text/plain');
					Respond(404)(message);
				}			

				remainRequestCount--;

			} while ( !oHeaders.Is('Connection', 'close') );
		
		} finally {

			SendData(function() void connection.Disconnect()); // true for async
			SendData = function() UNAVAILABLE;
			totalConnectionCount--; // even if the disconnection may occurs after this line (because connection.Write is async)
		}
	}
*/

	function HttpRequest(iStatus, iHeaders, Send) {

		
		this.OnBodyData = Noop;
		this.OnEndOfBody = Noop;
		this.OnDisconnected = Noop;
		


		this.EndOfResponse = function(statusCode, protoVersion) {
			
		}
	}


	function HttpConnection(connection, remainRequestCount, keepAliveTimeout) {
		
		var input = new Buffer();
		var connectionDataRate = new SingleRateMeter(getData($MD.connectionDataRate));
		var timeout;
		
		totalConnectionCount++;

		ResetTimeout();
		SetDataHandler(ProcessHttpHeader);
		
		function ResetTimeout() {
			
			timeout && io.RemoveTimeout(timeout);
			timeout = io.AddTimeout( keepAliveTimeout, function() Send( function() void connection.Disconnect() ) );
		}

		var dataHandler;
		function SetDataHandler(handler) {
			
			dataHandler = handler;
			if ( input.length )
				dataHandler();
		}

		connection.OnData = function() {

			var data = c.Read();
			input.Write(data);
			if ( !connectionDataRate.Inc(data.length) )
				c.Sleep( connectionDataRate.RestTime() );
			dataHandler();
		}
			
		connection.OnDisconnected = function(c) { // OnFailed ?
			
			io.RemoveTimeout(timeout);
			totalConnectionCount--;
		}

		var Send = function(item) {
			
			connection.Write(item, true);
			return ''; // all data has been sent
		}



		function ProcessHttpHeader() {

			if ( input.IndexOf(CRLF+CRLF) == -1 )
				return;
			
			SetDataHandler(Noop);

			remainRequestCount--;
			ResetTimeout();

			var iStatus = ParseHttpStatus( input );
			var iHeaders = ParseHttpHeaders( input );
			var oHeaders = new HttpHeaders(); // beware: do not set 'Connection' or 'Content-Length'
			oHeaders.Set( 'Date', new Date().toUTCString() );
			oHeaders.Set( 'Server', _name );
			oHeaders.Set( 'Expires', '0' );
			oHeaders.Set( 'Cache-Control', 'no-cache' );
			oHeaders.Set( 'Pragma', 'no-cache' );
			oHeaders.Set( 'Content-Type', 'text/html' );
			
			Print( connection.peerName + ' ' + iStatus.method + ' ' + iStatus.path + ' ' + iStatus.query, '\n' );
			
			function EndOfResponse() {

				if ( oHeaders.Is('Connection', 'close') ) {

					Send( function() void connection.Disconnect() );
					Send = function(data) data;
				} else
					SetDataHandler(ProcessHttpHeader);
			}
			
			function Respond(statusCode, protoVersion) {

				statusCode = statusCode || 200;
				protoVersion = protoVersion || iStatus.protoVersion;
				protoVersion > iStatus.protoVersion && ReportFailure('HTTP version too high ('+protoVersion+')');
				if ( iStatus.protoVersion >= 1.1 && iHeaders.Is('Connection', 'keep-alive') && !oHeaders.Is('Connection', 'close') && remainRequestCount > 0 && (oHeaders.Has('Content-Length') || oHeaders.Is('Transfer-Encoding', 'chunked')) ) {

					oHeaders.Set('Connection', 'keep-klive' );
					oHeaders.Set('Keep-Alive', 'timeout='+(keepAliveTimeout/SECOND).toFixed()+', max='+remainRequestCount );
				} else {
					oHeaders.Set('Connection', 'close');
				}
				Send( CreateHttpHeaders( statusCode, protoVersion, oHeaders ) )
				return function(data) Send( data );
			}			

			var requestHandler;
			for each ( let [matchFct, requestHandlerConstructor] in _requestHandlerList )
				if ( matchFct(iStatus.path) ) {
				
					requestHandler = requestHandlerConstructor( iStatus, iHeaders, oHeaders, Respond, EndOfResponse );
					break;
				}
			
			if ( !requestHandler ) {

				var message = 'Unable to handle ' + iStatus.path;
				oHeaders.Set('Content-Length', message.length);
				oHeaders.Set('Content-Type', 'text/plain');
				oHeaders.Set('Connection', 'close');
				Respond(404)(message);
				EndOfResponse();
				return;
			}

			switch ( iStatus.method ) {

				case 'GET':
					requestHandler.OnEndOfBody();
					return;
				case 'POST':
					var iclen = iHeaders.Get('Content-Length');
					SetDataHandler(function() {
					
						if ( input.length >= iclen ) {

							requestHandler.OnBodyData && requestHandler.OnBodyData(input.Read(iclen));
							iclen = 0;
						} else {
							iclen -= input.length;
							requestHandler.OnBodyData && requestHandler.OnBodyData(input.Read(iclen));
						}
						if ( iclen == 0 ) {
							
							SetDataHandler(Noop);
							requestHandler.OnEndOfBody();
						}
					}
					return;
				default:
					ReportWarning('...Unable to manage this request.');
					oHeaders.Set('Connection', 'close');
					Respond(204);
					EndOfResponse();
					return;
			}
		}
	}



	function StartServer() {

		var incomingConnectionRatePerPeer = new MultiRateMeter(getData($MD.incomingConnectionRatePerPeer));
		
		var serverConnection = new TCPServer( getData($MD.port), getData($MD.bind), getData($MD.socketBackLog) );
		serverConnection.OnIncoming = function(connection) {
			
			if ( totalConnectionCount > getData($MD.maxConnections) || !incomingConnectionRatePerPeer.Inc(connection.peerName, 1) ) {
				
				connection.Close();
				return;
			}

//			StartAsyncProc( ProcessConnectionProc(connection, getData($MD.connectionKeepAliveMax), getData($MD.connectionKeepAliveTimeout)) );
			new HttpConnection(connection, getData($MD.connectionKeepAliveMax), getData($MD.connectionKeepAliveTimeout));
		}
	}
	
	this.moduleApi = {
		
		AddRequestHandler: function( pathRegExpr, requestHandlerConstructor ) _requestHandlerList[String(pathRegExpr)] = [pathRegExpr, requestHandlerConstructor],
		RemoveRequestListener: function( pathRegExpr ) delete _requestHandlerList[String(pathRegExpr)]
	};
	
	
	
	
	this.stateListener = [
		{
			set: function(s) s[STATE_RUNNING] && s[_name],
			reset: function(s) !s[STATE_RUNNING] || !s[_name],
			trigger: function(polarity) {
			
				if (polarity) {
					
					StartServer();
//					$A.AddRequestHandler( /^\/dccFiles\//, ProcessFileRequest );
					$A.AddRequestHandler( /^\/cons/, ProcessConsoleAccess );
				} else {

					// kill all consoles
				}
				
			}
		}
	];	

})
