/* ***** BEGIN LICENSE BLOCK *****
 * Version: GNU GPL 2.0
 *
 * The contents of this file are subject to the
 * GNU General Public License Version 2.0; you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * ***** END LICENSE BLOCK ***** */

(function webServerModule($D, $A, $S) {
	
	LoadModule('jsz');
	
	this.disabled = false;
	var _name = this.name = this.constructor.name;
	var $MD = $D[_name];

	const mimeType = {
		htm:'text/html',
		html:'text/html',
		xml:'text/xml',
		gif:'image/gif',
		jpeg:'image/jpeg',
		jpg:'image/jpeg',
		jpe:'image/jpeg',
		svg:'image/svg+xml'
	};

	const reasonPhrase = {
		100: 'Continue',
		101: 'Switching Protocols',
		
		200: 'OK',
		201: 'Created',
		202: 'Accepted',
		203: 'Non-Authoritative Information',
		204: 'No Content',
		205: 'Reset Content',
		206: 'Partial Content',
		
		300: 'Multiple Choices',
		301: 'Moved Permanently',
		302: 'Found',
		303: 'See Other',
		304: 'Not Modified',
		305: 'Use Proxy',
		307: 'Temporary Redirect',
		
		400: 'Bad Request',
		401: 'Unauthorized',
		402: 'Payment Required',
		403: 'Forbidden',
		404: 'Not Found',
		405: 'Method Not Allowed',
		406: 'Not Acceptable',
		407: 'Proxy Authentication Required',
		408: 'Request Time-out',
		409: 'Conflict',
		410: 'Gone',
		411: 'Length Required',
		412: 'Precondition Failed',
		413: 'Request Entity Too Large',
		414: 'Request-URI Too Large',
		415: 'Unsupported Media Type',
		416: 'Requested range not satisfiable',
		417: 'Expectation Failed',
		
		500: 'Internal Server Error',
		501: 'Not Implemented',
		502: 'Bad Gateway',
		503: 'Service Unavailable',
		504: 'Gateway Time-out',
		505: 'HTTP Version not supported'
	};


	// Tools

	function MimeTypeByFileName(fileName) {

		return mimeType[fileName.substr(fileName.lastIndexOf(DOT)+1)] || 'text/html; charset=iso-8859-1';
	}

	function NormalizeHeaderName(rawName) {
		
		return [ h[0].toUpperCase()+h.substr(1) for each( h in rawName.split('-')) ].join('-');
	}

	function ParseHeaders(buffer) { // (TBD) try with  /(.*?): ?(.*?)\r?\n/g;

		try {
			var lines = buffer.split(CRLF);
			var [method,url,proto] = lines[0].split(SPC);
			var httpVersion = Number(proto.split(SLASH)[1]);
			var [path,query] = url.split('?');
			var status = { method:method, url:url, httpVersion:httpVersion, path:path, query:query };
			var headers = {};
			for ( var i=1; lines[i].length; i++ ) {
			
				var [name,value] = lines[i].split(':');
				headers[NormalizeHeaderName(name)] = Trim(value);
			}
		} catch(error) {

			throw ReportFailure( 'header parsing error (see log file)' );
		}
		return [ status, headers ];
	}


	function CreateHttpHeaders( statusCode, httpVersion, headers ) {

		var buf = 'HTTP/' + httpVersion + SPC + statusCode + SPC + reasonPhrase[statusCode] + CRLF;
		for ( var [h,v] in Iterator(headers) )
			buf += h + ': ' + v + CRLF;
		return buf + CRLF;
	}

	
	function UrlDecodeString(str) {
		
		var qvar = {};
		if ( str )
			for each ( var p in str.split('&') )
				let ( [key, val] = p.split('=') )
					qvar[key] = val;
		return qvar;
	}


	function NormalizePath( path ) { // (TBD) try with regexp

		var epath = path.split('/');
		var newPath = [];
		for each ( var name in epath )
			switch (name) {
			case '..':
				newPath.pop();
				break;
			case '.':
			case '':
				break;
			default:
				newPath.push(name);
			}
		return newPath.join('/');
	}



	function ProcessFileRequest( iStatus, iHeaders, oHeaders, Respond ) {

		var root='./';
		var data = '';
		
		var fileName = root + NormalizePath(iStatus.path);
		var file = new File( fileName );
		if ( !file.exist || file.info.type != File.FILE_FILE ) {

			var message = 'file '+fileName+' not found';
			oHeaders['Content-Length'] = message.length;
			oHeaders['Content-Type'] = 'text/plain';
			Respond(404)(message);
			return;
		}
		
		this.OnData = function(buf) data += buf;

		this.OnEndOfData = function() {

			oHeaders['Content-Type'] = MimeTypeByFileName( fileName );

			var useChunksEncoding = false;
			if (iStatus.httpVersion >= 1.1) {
			
				useChunksEncoding = true;				
				oHeaders['Transfer-Encoding'] = 'chunked';
			}

			var ContentEncoding = Identity;
			if ( iHeaders['Accept-Encoding'] && iHeaders['Accept-Encoding'].indexOf('deflate') != -1 ) {

				oHeaders['Content-Encoding'] = 'deflate';
				ContentEncoding = new Z(Z.DEFLATE);
			}

			file.Open( File.RDONLY );
			Respond(200)( function() {

				var data = file.Read(Z.idealInputLength);
				if ( data.length ) {

					data = ContentEncoding(data);
					if ( useChunksEncoding )
						return [ data.length.toString(16) + CRLF, data, CRLF ];
					else
						return [ data ];
				}
				file.Close();
				return false;
			} );
			if ( useChunksEncoding )
				res( '0' + CRLF + CRLF );
		}
	}

	
	var _consoles = {};
	
	function ProcessConsoleAccess( iStatus, iHeaders, oHeaders, Respond ) {
		
		if ( !iStatus.query ) {

			let content = new File('./webConsole.html').content; // (TBD) filename from config
			oHeaders['Content-Length'] = content.length;
			Respond(200)(content);
			return;
		}
		
		var qvar = UrlDecodeString(iStatus.query);

		if ( 'sid' in qvar && qvar.sid in _consoles )
			_consoles[qvar.sid].count++;
		
		if ( qvar.action == 'new' )	{

			let sid = RandomString(32);
			_consoles[sid] = { count:0 };
			oHeaders['Content-Length'] = sid.length;
			Respond(200)(sid);
			return;
		}


		if ( 'async' in qvar && qvar.sid in _consoles ) {
			
			_consoles[qvar.sid].Write = function(data) {
				
				oHeaders['Content-Length'] = data.length;
				Respond(200)(data);
			}
			return;
		}

		if ( qvar.action != 'submit' ) {
			
			Respond(204);
			return;
		}
			
		var consData = '';
		this.OnData = function(buf) consData += buf;
		
		this.OnEndOfData = function() {
			
			let message;
			if ( qvar.sid in _consoles ) {

				message = String(_consoles[qvar.sid].count);
				message += ' '+consData + '<br>';
			} else {
				
				message = '<span style="color:red">Invalid session.</span><br/>';
			}

			oHeaders['Content-Length'] = message.length;
			Respond(200)(message);
		}	
	}

	var _requestHandlerList = {};

	var connectionCount = 0;

	function ProcessConnectionProc(connection, remainRequestCount, keepAliveTimeout) { // this async procedure manages the lifetime of an HTTP connection

		connectionCount++;
		var input = new Buffer();
		function SendData(item) connection.Write(item, true); // true for async 
		var connectionDataRate = new SingleRateMeter(getData($MD.connectionDataRate));
		
		try {

			do {

				var status, data, pr, eoh;

				[status] = yield AsyncConnectionWaitData(connection, keepAliveTimeout);
				if ( status != OK ) // == TIMEOUT
					AbortAsyncProc();

				do {

					[status, data] = yield AsyncConnectionRead(connection);
					if ( status != OK || !data )
						AbortAsyncProc();

					if ( !connectionDataRate.Inc(data.length) )
						yield AsyncSleep( connectionDataRate.RestTime() );

					input.Write(data);
					eoh = input.IndexOf(CRLF+CRLF);
				} while (eoh == -1);

				var [iStatus, iHeaders] = ParseHeaders( input.Read(eoh+4) );
				
				ReportNotice( connection.peerName + ' ' + iStatus.method + ' ' + iStatus.path + ' ' + iStatus.query, '\n' );

				var oHeaders = { // default header values
					'Date': new Date().toUTCString(),
					'Server': _name,
					'Expires': '0',
					'Cache-Control': 'no-cache',
					'Pragma': 'no-cache',
					'Content-Type': 'text/html'
					// beware: do not set 'Connection' and 'Content-Length'
				};
				
				function Respond(statusCode, httpVersion) {
					
					statusCode = statusCode || 200;
					httpVersion = httpVersion || iStatus.httpVersion;
					httpVersion > iStatus.httpVersion && ReportFailure('HTTP version too high ('+httpVersion+')');

					if ( iStatus.httpVersion >= 1.1 && iHeaders['Connection'] == 'keep-alive' && oHeaders['Connection'] != 'close' && remainRequestCount > 0 && (oHeaders['Content-Length'] != undefined || oHeaders['Transfer-Encoding'] == 'chunked') ) {

						oHeaders['Connection'] = 'keep-klive';
						oHeaders['Keep-Alive'] = 'timeout='+(keepAliveTimeout/SECOND).toFixed()+', max='+remainRequestCount;
					} else {
						oHeaders['Connection'] = 'close';
					}
					SendData( CreateHttpHeaders( statusCode, httpVersion, oHeaders ) );
					return SendData;
				}

				var requestHandler = undefined;
				for each ( let [pathRegExpr, requestHandlerConstructor] in _requestHandlerList ) {

					if ( !pathRegExpr(iStatus.path) )
						continue;
					requestHandler = new requestHandlerConstructor( iStatus, iHeaders, oHeaders, Respond );
					break;
				}

				if ( requestHandler ) {

					switch ( iStatus.method.toLowerCase() ) {
						case 'get':
							break;
						case 'post':
							var iclen = iHeaders['Content-Length'];
							do {

								if ( input.length < iclen ) {

									[status, data] = yield AsyncConnectionRead(connection);
									if (status != OK || !data)
										AbortAsyncProc();

									if ( !connectionDataRate.Inc(data.length) )
										yield AsyncSleep( connectionDataRate.RestTime() );

									input.Write(data);
								}

								if ( input.length > iclen ) {

									requestHandler.OnData && requestHandler.OnData(input.Read(iclen));
									iclen = 0;
								} else {

									iclen -= input.length;
									requestHandler.OnData && requestHandler.OnData(input.Read());
								}
							} while (iclen);
							break;
						default:
							ReportWarning('...Unable to manage this request.');
							Respond(204);
					}
					requestHandler.OnEndOfData && requestHandler.OnEndOfData();
				} else {

					var message = 'Unable to handle ' + iStatus.path;
					oHeaders['Content-Length'] = message.length;
					oHeaders['Content-Type'] = 'text/plain';
					Respond(404)(message);
				}			

				remainRequestCount--;

			} while ( oHeaders['Connection'] != 'close' );
		
		} finally {

			SendData( function() void connection.Disconnect() );
			connectionCount--; // even if the disconnection may occurs after this line (because SendData is async)
		}
	}




	function StartServer() {

		var connectionRate = new SingleRateMeter(getData($MD.incomingConnectionRate));
		var serverConnection = new TCPServer( getData($MD.port), getData($MD.bind), getData($MD.socketBackLog) );
		serverConnection.OnIncoming = function(connection) {

			if ( connectionCount > getData($MD.maxConnections) || !connectionRate.Inc(1) ) {
				
				connection.Close();
				return;
			}

			StartAsyncProc( ProcessConnectionProc(connection, getData($MD.connectionKeepAliveMax), getData($MD.connectionKeepAliveTimeout)) );
		}
	}
	
	this.moduleApi = {
		
		AddRequestHandler: function( pathRegExpr, requestHandlerConstructor ) _requestHandlerList[String(pathRegExpr)] = [pathRegExpr, requestHandlerConstructor],
		RemoveRequestListener: function( pathRegExpr ) delete _requestHandlerList[String(pathRegExpr)]
	};
	
	
	
	
	this.stateListener = [
		{
			set: function(s) s[STATE_RUNNING] && s[_name],
			reset: function(s) !s[STATE_RUNNING] || !s[_name],
			trigger: function(polarity) {
			
				if (polarity) {
					
					StartServer();
//					$A.AddRequestHandler( /^\/dccFiles\//, ProcessFileRequest );
					$A.AddRequestHandler( /^\/cons/, ProcessConsoleAccess );
				} else {

					// kill all consoles
				}
				
			}
		}
	];	

})
