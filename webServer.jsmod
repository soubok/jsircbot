/* ***** BEGIN LICENSE BLOCK *****
 * Version: GNU GPL 2.0
 *
 * The contents of this file are subject to the
 * GNU General Public License Version 2.0; you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * ***** END LICENSE BLOCK ***** */

(function webServerModule($D, $A, $S) {
	
	LoadModule('jsz');
	
	this.disabled = false;
	var _name = this.name = this.constructor.name;
	var $MD = $D[_name];

	const mimeType = {
		htm:'text/html',
		html:'text/html',
		xml:'text/xml',
		gif:'image/gif',
		jpeg:'image/jpeg',
		jpg:'image/jpeg',
		jpe:'image/jpeg',
		svg:'image/svg+xml'
	};

	const reasonPhrase = {
		100: 'Continue',
		101: 'Switching Protocols',
		
		200: 'OK',
		201: 'Created',
		202: 'Accepted',
		203: 'Non-Authoritative Information',
		204: 'No Content',
		205: 'Reset Content',
		206: 'Partial Content',
		
		300: 'Multiple Choices',
		301: 'Moved Permanently',
		302: 'Found',
		303: 'See Other',
		304: 'Not Modified',
		305: 'Use Proxy',
		307: 'Temporary Redirect',
		
		400: 'Bad Request',
		401: 'Unauthorized',
		402: 'Payment Required',
		403: 'Forbidden',
		404: 'Not Found',
		405: 'Method Not Allowed',
		406: 'Not Acceptable',
		407: 'Proxy Authentication Required',
		408: 'Request Time-out',
		409: 'Conflict',
		410: 'Gone',
		411: 'Length Required',
		412: 'Precondition Failed',
		413: 'Request Entity Too Large',
		414: 'Request-URI Too Large',
		415: 'Unsupported Media Type',
		416: 'Requested range not satisfiable',
		417: 'Expectation Failed',
		
		500: 'Internal Server Error',
		501: 'Not Implemented',
		502: 'Bad Gateway',
		503: 'Service Unavailable',
		504: 'Gateway Time-out',
		505: 'HTTP Version not supported'
	};


	// Tools

	function MimeTypeByFileName(fileName) {

		return mimeType[fileName.substr(fileName.lastIndexOf(DOT)+1)] || 'text/html; charset=iso-8859-1';
	}

	function NormalizeHeaderName(rawName) {
		
		return [ h[0].toUpperCase()+h.substr(1) for each( h in rawName.split('-')) ].join('-');
	}

	function ParseHeaders(buffer) { // (TBD) try with  /(.*?): ?(.*?)\r?\n/g;

		try {
			var lines = buffer.split(CRLF);
			var [method,url,proto] = lines[0].split(SPC);
			var httpVersion = Number(proto.split(SLASH)[1]);
			var [path,query] = url.split('?');
			var status = { method:method, url:url, httpVersion:httpVersion, path:path, query:query };

			var headers = new HttpHeaders();
			for ( var i=1; lines[i].length; i++ ) {
			
				var [name,value] = lines[i].split(': ');
				//headers[NormalizeHeaderName(name)] = Trim(value);
				headers.Set(name,value);
			}
		} catch(error) {

			throw ReportFailure( 'header parsing error (see log file)' );
		}
		return [ status, headers ];
	}



	function HttpHeaders() {

		var _headers = {};		
		this.Parse = function(rawHeaders) {

			var hre = /(.*?): ?(.*?)\r?\n/g;
			var res;
			for ( hre.lastIndex = 0; res = _rexp_keyval.exec(rawHeaders); _headers[res[1]] = res[2]);
		}
		this.Has = function(name) {
			
			return name in _headers;
		}
		this.Set = function(name, value) {
			
			_headers[name] = value;
		}
		this.Get = function(name) {
			
			return _headers[name];
		}
		this.Is = function(name, value) {
			
			return name in _headers && _headers[name].toLowerCase() == value.toLowerCase();
		}
		this.Serialize = function() {
			
			var tmp = '';
			for ( var [h,v] in Iterator(_headers) )
				tmp += h + ': ' + v + CRLF;
			return tmp;
		}
	}



	function CreateHttpHeaders( statusCode, httpVersion, headers ) {

		var buf = 'HTTP/' + httpVersion + SPC + statusCode + SPC + reasonPhrase[statusCode] + CRLF;
		return buf + headers.Serialize() + CRLF;
	}

	
	function ParseQueryData(str) {
		
		var map = {};
		if ( str )
			for each ( var p in str.split('&') )
				let ( [key, val] = p.split('=') ) // report a "strict warning: reference to undefined property 1" because 'foo'.split('=') do not have a [1]
					map[key] = val;
		return map;
	}
	
	function ParseCookieData(str) {
		
		var map = {};
		if ( str )
			for each ( var p in str.split('; ') )
				let ( [key, val] = p.split('=') )
					map[key] = val;
		return map;
	}
	
	function SaveData(name, data) {

		var expires = new Date;
		expires.setDate(expires.getDate() + 365); // espires in 1 year
		document.cookie = name + "=" + encodeURIComponent(data) + ";expires=" + expires.toGMTString();
	}


	function LoadData(name) {

		 if (document.cookie.length) {

			  var start = document.cookie.indexOf(name + "=");
			  if (start != -1) {

					start = start + name.length + 1;
					var end = document.cookie.indexOf(";", start);
					if (end == -1)
						 end = document.cookie.length;
					return decodeURIComponent(document.cookie.substring(start, end));
			  }
		 }
		 return "";
	}	


	function NormalizePath( path ) { // (TBD) try with regexp

		var epath = path.split('/');
		var newPath = [];
		for each ( var name in epath )
			switch (name) {
			case '..':
				newPath.pop();
				break;
			case '.':
			case '':
				break;
			default:
				newPath.push(name);
			}
		return newPath.join('/');
	}



	function ProcessFileRequest( iStatus, iHeaders, oHeaders, Respond ) {

		var root='./';
		var data = '';
		
		var fileName = root + NormalizePath(iStatus.path);
		var file = new File( fileName );
		if ( !file.exist || file.info.type != File.FILE_FILE ) {

			var message = 'file '+fileName+' not found';
			oHeaders.Set('Content-Length', message.length);
			oHeaders.Set('Content-Type', 'text/plain');
			Respond(404)(message);
			return;
		}
		
		this.OnBodyData = function(buf) data += buf;

		this.OnEndOfBody = function() {

			oHeaders.Set('Content-Type', MimeTypeByFileName(fileName));

			var useChunksEncoding = false;
			if (iStatus.httpVersion >= 1.1) {
			
				useChunksEncoding = true;				
				oHeaders.Set('Transfer-Encoding', 'chunked');
			}

			var ContentEncoding = Identity;
			if ( iHeaders.Has('Accept-Encoding') && iHeaders.Get('Accept-Encoding').indexOf('deflate') != -1 ) {

				oHeaders.Set('Content-Encoding', 'deflate');
				ContentEncoding = new Z(Z.DEFLATE);
			}

			file.Open( File.RDONLY );
			Respond(200)( function() {

				var data = file.Read(Z.idealInputLength);
				if ( data.length ) {

					data = ContentEncoding(data);
					if ( useChunksEncoding )
						return [ data.length.toString(16) + CRLF, data, CRLF ];
					else
						return [ data ];
				}
				file.Close();
				return false;
			} );
			if ( useChunksEncoding )
				res( '0' + CRLF + CRLF );
		}
	}

	
	var _consoles = {};
	
	function ProcessConsoleAccess( iStatus, iHeaders, oHeaders, Respond ) {

		var query = ParseQueryData(iStatus.query);
		var cookie = ParseCookieData(iHeaders.Get('Cookie'));
		

		var sid = cookie.sid;
		var action = query.action;
		
		if ( !action ) {

			let content = new File('./webConsole.html').content; // (TBD) filename from config
			oHeaders.Set('Content-Length', content.length);

			let sid = RandomString(32);
			_consoles[sid] = { sid:sid, count:0, pendingMessages:[] };
			oHeaders.Set('Set-Cookie', 'sid='+sid+'; path='+iStatus.path);// Set-Cookie: <name>=<value>[; <name>=<value>]... [; expires=<date>][; domain=<domain_name>][; path=<some_path>][; secure][; httponly]
			Respond(200)(content);
			return;
		}
		
		if ( action == 'wait' && sid in _consoles ) {
			
			_consoles[sid].Write = function(data) {
				
				oHeaders.Set('Content-Length', data.length);
				var status = Respond(200)(data);
			}
			
			io.AddTimeout( 2000, function() { _consoles[sid].Write('test<br/>') })
			return;
		}

		if ( action != 'submit' ) {
			
			Respond(204);
			return;
		}
			
		var consData = '';
		this.OnBodyData = function(buf) consData += buf;
		
		this.OnEndOfBody = function() {
			
			let message;
			if ( sid in _consoles ) {

				message = String(_consoles[sid].count);
				message += ' '+consData + '<br>';
			} else {
				
				message = '<span style="color:red">Invalid session.</span><br/>';
			}

			oHeaders.Set('Content-Length', message.length);
			Respond(200)(message);
		}	
	}

	var _requestHandlerList = {};

	var totalConnectionCount = 0;

	function ProcessConnectionProc(connection, remainRequestCount, keepAliveTimeout) { // this async procedure manages the lifetime of an HTTP connection

		totalConnectionCount++;
		var input = new Buffer();
		function SendData(data) {
			
			connection.Write(data, true);
			return OK;
		}

		var connectionDataRate = new SingleRateMeter(getData($MD.connectionDataRate));
		
		try {

			do {

				var status, data, pr, eoh;

				[status] = yield AsyncConnectionWaitData(connection, keepAliveTimeout);
				if ( status != OK ) // TIMEOUT || DISCONNECTED
					AbortAsyncProc();

				do {

					[status, data] = yield AsyncConnectionRead(connection);
					if ( status != OK || !data )
						AbortAsyncProc();
					input.Write(data);
					eoh = input.IndexOf(CRLF+CRLF);
				} while (eoh == -1);

				if ( !connectionDataRate.Inc(input.length) )
					yield AsyncSleep( connectionDataRate.RestTime() );
				var [iStatus, iHeaders] = ParseHeaders( input.Read(eoh+4) );

				ReportNotice( connection.peerName + ' ' + iStatus.method + ' ' + iStatus.path + ' ' + iStatus.query, '\n' );

				
				var oHeaders = new HttpHeaders();
				oHeaders.Set( 'Date', new Date().toUTCString() );
				oHeaders.Set( 'Server', _name );
				oHeaders.Set( 'Expires', '0' );
				oHeaders.Set( 'Cache-Control', 'no-cache' );
				oHeaders.Set( 'Pragma', 'no-cache' );
				oHeaders.Set( 'Content-Type', 'text/html' );
				// beware: do not set 'Connection' or 'Content-Length'
				
				function Respond(statusCode, httpVersion) {
					
					statusCode = statusCode || 200;
					httpVersion = httpVersion || iStatus.httpVersion;
					httpVersion > iStatus.httpVersion && ReportFailure('HTTP version too high ('+httpVersion+')');

					if ( iStatus.httpVersion >= 1.1 && iHeaders.Is('Connection', 'keep-alive') && !oHeaders.Is('Connection', 'close') && remainRequestCount > 0 && (oHeaders.Has('Content-Length') || oHeaders.Is('Transfer-Encoding', 'chunked')) ) {

						oHeaders.Set('Connection', 'keep-klive' );
						oHeaders.Set('Keep-Alive', 'timeout='+(keepAliveTimeout/SECOND).toFixed()+', max='+remainRequestCount );
					} else {
						oHeaders.Set('Connection', 'close');
					}
					
					SendData( CreateHttpHeaders( statusCode, httpVersion, oHeaders ), true); // true for async
					
					return function(data) SendData(data);
				}

				var requestHandler = undefined;
				for each ( let [pathRegExpr, requestHandlerConstructor] in _requestHandlerList ) {

					if ( !pathRegExpr(iStatus.path) )
						continue;
					requestHandler = new requestHandlerConstructor( iStatus, iHeaders, oHeaders, Respond );
					break;
				}

				if ( requestHandler ) {

					switch ( iStatus.method.toLowerCase() ) {
						case 'get':
							break;
						case 'post':
							var iclen = iHeaders.Get('Content-Length');
							do {

								if ( input.length < iclen ) {

									[status, data] = yield AsyncConnectionRead(connection);
									if (status != OK || !data)
										AbortAsyncProc();

									if ( !connectionDataRate.Inc(data.length) )
										yield AsyncSleep( connectionDataRate.RestTime() );

									input.Write(data);
								}

								if ( input.length > iclen ) {

									requestHandler.OnBodyData && requestHandler.OnBodyData(input.Read(iclen));
									iclen = 0;
								} else {

									iclen -= input.length;
									requestHandler.OnBodyData && requestHandler.OnBodyData(input.Read());
								}
							} while (iclen);
							break;
						default:
							ReportWarning('...Unable to manage this request.');
							Respond(204);
					}
					requestHandler.OnEndOfBody && requestHandler.OnEndOfBody();
				} else {

					var message = 'Unable to handle ' + iStatus.path;
					oHeaders.Set('Content-Length', message.length);
					oHeaders.Set('Content-Type', 'text/plain');
					Respond(404)(message);
				}			

				remainRequestCount--;

			} while ( !oHeaders.Is('Connection', 'close') );
		
		} finally {

			SendData(function() void connection.Disconnect()); // true for async
			function SendData() UNAVAILABLE;
			totalConnectionCount--; // even if the disconnection may occurs after this line (because connection.Write is async)
		}
	}




	function StartServer() {

		var incomingConnectionRatePerPeer = new MultiRateMeter(getData($MD.incomingConnectionRatePerPeer));
		
		var serverConnection = new TCPServer( getData($MD.port), getData($MD.bind), getData($MD.socketBackLog) );
		serverConnection.OnIncoming = function(connection) {
			
			if ( totalConnectionCount > getData($MD.maxConnections) || !incomingConnectionRatePerPeer.Inc(connection.peerName, 1) ) {
				
				connection.Close();
				return;
			}

			StartAsyncProc( ProcessConnectionProc(connection, getData($MD.connectionKeepAliveMax), getData($MD.connectionKeepAliveTimeout)) );
		}
	}
	
	this.moduleApi = {
		
		AddRequestHandler: function( pathRegExpr, requestHandlerConstructor ) _requestHandlerList[String(pathRegExpr)] = [pathRegExpr, requestHandlerConstructor],
		RemoveRequestListener: function( pathRegExpr ) delete _requestHandlerList[String(pathRegExpr)]
	};
	
	
	
	
	this.stateListener = [
		{
			set: function(s) s[STATE_RUNNING] && s[_name],
			reset: function(s) !s[STATE_RUNNING] || !s[_name],
			trigger: function(polarity) {
			
				if (polarity) {
					
					StartServer();
//					$A.AddRequestHandler( /^\/dccFiles\//, ProcessFileRequest );
					$A.AddRequestHandler( /^\/cons/, ProcessConsoleAccess );
				} else {

					// kill all consoles
				}
				
			}
		}
	];	

})
