/* ***** BEGIN LICENSE BLOCK *****
 * Version: GNU GPL 2.0
 *
 * The contents of this file are subject to the
 * GNU General Public License Version 2.0; you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * ***** END LICENSE BLOCK ***** */


(function CommandEventModule() {
	
	this.name = this.constructor.name;
	var _mod = this;
	
	const _maxServerReplyInterval = 1000;
	const _maxUserReplyInterval = 10000;
	
	var _userHostParser = /(.+?)(\*?)=(\+?)(?:.*?)@(.*)/;
	
	var _callList = [];
	function ScheduleCall(fct) {
		
		_callList.push(fct);
		if ( _callList.length == 1 )
			_callList[0]();
	}
	
	function NextCall() {
		
		_callList.shift();
		_callList.length && _callList[0]();
	}
	
	
	_mod.moduleApi = {
	
		UserHost: function( nickList, OnReply ) {

			var pingData = RandomString(16);
		
			ScheduleCall(function() {

				var timeoutId, events = {};
				
				_mod.AddMessageListenerSet(events);

				function End(reply) {

					_mod.RemoveMessageListenerSet(events);
					io.RemoveTimeout(timeoutId);
					NextCall();
					OnReply(reply);
				}

				function Error( command, from, to, erroneousCommand, reasonPhrase ) {

					if ( erroneousCommand == 'USERHOST' )
						End();
				}

				function UserHostResponse( command, from, to, hostList ) {

					var result = {};
					for each ( var userhost in hostList.split(' ') ) {

						var match = _userHostParser(userhost);
						if ( userhost && match ) {

							var [, nick, ircOp, hasAwayMsg, host] = match;
							result[nick] = host;
						}
					}
					End(result);
				}

				events.PONG = function(command, from, server, data) {

					if ( data != pingData )
						return;
					delete events.PONG;
					events.RPL_USERHOST = UserHostResponse;
					events.ERR_NEEDMOREPARAMS = Error;
				}
				
				// the PING ensure that the RPL_USERHOST is related to the right USERHOST
				_mod.Send( ['PING '+pingData, 'USERHOST '+nickList.join(' ')], false, function() {

					timeoutId = io.AddTimeout(_maxServerReplyInterval, End ); // start the timeout ONLY vhen the message has been sent
				});
			});
		},
		

		Prompt: function( nick, message, OnReply ) {
			
			ScheduleCall(function() {

				var timeoutId, events;

				function End(message) {

					_mod.RemoveMessageListenerSet(events);
					io.RemoveTimeout(timeoutId);
					NextCall();
					OnReply(message);
				}
				
				function Error() End(); // we need to ignore Error arguments because on error, OnReply must be called w/o arguments

				function Reply( command, from, to, message ) {

					if ( to == getData( _mod.data.nick ) && nick == StrBefore(from, '!') )
						End(message);
				}
				events = { PRIVMSG:Reply, ERR_NORECIPIENT:Error, ERR_NOTEXTTOSEND:Error, ERR_CANNOTSENDTOCHAN:Error, ERR_NOTOPLEVEL:Error, ERR_WILDTOPLEVEL:Error, ERR_TOOMANYTARGETS:Error, ERR_NOSUCHNICK:Error, RPL_AWAY:Error };
				_mod.AddMessageListenerSet(events);
				_mod.api.Privmsg( nick, message, function() {

					timeoutId = io.AddTimeout(_maxUserReplyInterval, End ); // start the timeout ONLY vhen the message has been sent
				});
			});
		},


		Sync: function( OnReply ) {
			
			var pingData = IntervalNow();
			
			ScheduleCall(function() {

				var timeoutId, events;

				function End(status) {

					_mod.RemoveMessageListenerSet(events);
					io.RemoveTimeout(timeoutId);
					NextCall();
					OnReply(status);
				}
				
				function Reply( command, from, server, data ) data == pingData && End(true);

				events = { PONG:Reply };

				_mod.AddMessageListenerSet(events);
				_mod.Send( 'PING '+pingData, false, function() {

					timeoutId = io.AddTimeout(_maxServerReplyInterval, End ); // start the timeout ONLY vhen the message has been sent
				});
			});
		}
		
		
	};
})


/*
302    RPL_USERHOST
              ":*1<reply> *( " " <reply> )"

         - Reply format used by USERHOST to list replies to
           the query list.  The reply string is composed as
           follows:

           reply = nickname [ "*" ] "=" ( "+" / "-" ) hostname

           The '*' indicates whether the client has registered
           as an Operator.  The '-' or '+' characters represent
           whether the client has set an AWAY message or not
           respectively.

eg:
USERHOST Wiz Michael syrk
:ircd.stealth.net 302 yournick :syrk=+syrk@millennium.stealth.net
*/
