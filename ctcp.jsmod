/* ***** BEGIN LICENSE BLOCK *****
 * Version: GNU GPL 2.0
 *
 * The contents of this file are subject to the
 * GNU General Public License Version 2.0; you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * ***** END LICENSE BLOCK ***** */

const X_DELIM = '\1';
const X_QUOTE = '\134'; // back slash
const SPC = '\040'; // space

(function CTCPModule() {

	var _mod = this;

	function lowLevelCtcpQuote(data) { // NUL, NL, CR, QUOTE -> QUOTE 0, QUOTE n, QUOTE r, QUOTE QUOTE
		
		var out='';
		for each ( var c in data )
			switch (c) {
				case '\0':
					out += '\0200';
					break;
				case '\r':
					out += '\020r';
					break;
				case '\n':
					out += '\020n';
					break;
				case '\020':
					out += '\020\020';
					break;
				default:
					out += c;
			}
		return out;		
	}

	function lowLevelCtcpDequote(data) {

		var out='';
		var len=data.length;
		for ( var i=0; i<len; i++ )
			if ( data[i]=='\020' )
				switch (data[++i]) {
				case '0':
					out += '\0';
					break;
				case 'r':
					out += '\r';
					break;
				case 'n':
					out += '\n';
					break;
				case '\020':
					out += '\020';
					break;
				}
			else
				out+=data[i];
		return out;		
	}

	function ctcpLevelQuote(data) { // \\, \1 -> \\\\, \\a

		var out='';
		for each ( var c in data )
			switch (c) {
			case X_DELIM:
				out += X_QUOTE + 'a';
				break;
			case X_QUOTE:
				out += X_QUOTE + X_QUOTE;
				break;
			default:
				out += c;
			}
		return out;
	}

	function ctcpLevelDequote(data) {

		var out='';
		var len=data.length;
		for ( var i=0; i<len; i++ )
			if ( data[i] == X_QUOTE )
				switch (data[++i]) {
				case X_QUOTE:
					out += X_QUOTE;
					break;
				case 'a':
					out += X_DELIM;
					break;
				}
			else
				out += data[i];
		return out;		
	}
	

	function DispatchCtcpMessage( from, to, ctcpMessage ) {

		var tag, data, pos = ctcpMessage.indexOf(SPC);
		if ( pos == -1 )
			tag = ctcpMessage;
		else {
			tag = ctcpMessage.substring( 0, pos );
			data = ctcpMessage.substring( pos + 1 );
		}
		_mod.FireModuleListener( 'ctcp', tag, from, to, data );
	}


	var _serverMessageListener = {
	
		NOTICE: function( command, from, to, msg ) { // ctcp response
		},

		PRIVMSG: function( command, from, to, msg ) {
			
			[ DispatchCtcpMessage( from, to, m ) for ( [i, m] in Iterator(msg.split(X_DELIM)) ) if ( i % 2 ) ];
		}
	}

	this.AddModuleListeners = function() _mod.AddMessageListenerSet( _serverMessageListener );
	this.RemoveModuleListeners = function() _mod.RemoveMessageListenerSet( _serverMessageListener );
	
	this.AddModuleAPI = function() {
	
		_mod.api.CtcpRequest = function(who, tag, data) _mod.Send( 'PRIVMSG ' + who + ' :' + lowLevelCtcpDequote( X_DELIM + ctcpLevelQuote(tag + SPC + data) + X_DELIM ) );
		_mod.api.CtcpResponse = function(who, tag, data) _mod.Send( 'NOTICE ' + who + ' :' + lowLevelCtcpDequote( X_DELIM + ctcpLevelQuote(tag + SPC + data) + X_DELIM ) );
	}
	
	this.RemoveModuleAPI = function() {

		delete _mod.api.CtcpRequest;
		delete _mod.api.CtcpResponse;
	}
})

/* Internet Relay Chat - Client To Client Protocol (CTCP):
	http://www.invlogic.com/irc/ctcp.html
	http://www.invlogic.com/irc/ctcpprot_04.html
	http://www.irchelp.org/irchelp/rfc/ctcpspec.html
*/