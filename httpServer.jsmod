/* ***** BEGIN LICENSE BLOCK *****
 * Version: GNU GPL 2.0
 *
 * The contents of this file are subject to the
 * GNU General Public License Version 2.0; you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * ***** END LICENSE BLOCK ***** */

(function webServerModule($D, $A, $S) {
	
	LoadModule('jsz');
	
	this.disabled = false;
	var _name = this.name = this.constructor.name;
	var $MD = $D[_name];

	const mimeType = {
		htm:'text/html',
		html:'text/html',
		xml:'text/xml',
		gif:'image/gif',
		jpeg:'image/jpeg',
		jpg:'image/jpeg',
		jpe:'image/jpeg',
		svg:'image/svg+xml'
	};

	const reasonPhrase = {
		100: 'Continue',
		101: 'Switching Protocols',
		
		200: 'OK',
		201: 'Created',
		202: 'Accepted',
		203: 'Non-Authoritative Information',
		204: 'No Content',
		205: 'Reset Content',
		206: 'Partial Content',
		
		300: 'Multiple Choices',
		301: 'Moved Permanently',
		302: 'Found',
		303: 'See Other',
		304: 'Not Modified',
		305: 'Use Proxy',
		307: 'Temporary Redirect',
		
		400: 'Bad Request',
		401: 'Unauthorized',
		402: 'Payment Required',
		403: 'Forbidden',
		404: 'Not Found',
		405: 'Method Not Allowed',
		406: 'Not Acceptable',
		407: 'Proxy Authentication Required',
		408: 'Request Time-out',
		409: 'Conflict',
		410: 'Gone',
		411: 'Length Required',
		412: 'Precondition Failed',
		413: 'Request Entity Too Large',
		414: 'Request-URI Too Large',
		415: 'Unsupported Media Type',
		416: 'Requested range not satisfiable',
		417: 'Expectation Failed',
		
		500: 'Internal Server Error',
		501: 'Not Implemented',
		502: 'Bad Gateway',
		503: 'Service Unavailable',
		504: 'Gateway Time-out',
		505: 'HTTP Version not supported'
	};


	// Tools

	function MimeTypeByFileName(fileName) {

		return mimeType[fileName.substr(fileName.lastIndexOf(DOT)+1)] || 'text/html; charset=iso-8859-1';
	}

	function NormalizeHeaderName(rawName) {
		
		return [ h[0].toUpperCase()+h.substr(1) for each( h in rawName.split('-')) ].join('-');
	}

	function ParseHttpStatus(buffer) {
		
		var status = NewDataObj();
		status.method = buffer.ReadUntil(SPC);
		status.url = buffer.ReadUntil(SPC);
		status.protoName = buffer.ReadUntil(SLASH);
		status.protoVersion = buffer.ReadUntil(CRLF);
		var [path,query] = status.url.split('?');
		status.path = path;
		status.query = query;
		return status;
	}
	
	function ParseHttpHeaders(buffer) {

		var headers = new HttpHeaders();
		for (;;) {
			var key = buffer.ReadUntil(': ');
			var value = buffer.ReadUntil(CRLF);
			if ( !key )
				break;
			headers.Set(key, value);
		}
		return headers;
	}

	function HttpHeaders() {

		var _headers = NewDataObj();
		this.Parse = function(rawHeaders) {
			
			var res, hre = /(.*?): ?(.*?)\r?\n/g;
			for ( hre.lastIndex = 0; res = hre.exec(rawHeaders); _headers[res[1]] = res[2]);
		}
		this.Has = function(name) {
			
			return name in _headers;
		}
		this.Set = function(name, value) {
			
			_headers[name] = value;
		}
		this.MSet = function(obj) {
			
			for ( var p in obj )
				_headers[p] = obj[p];
		}
		this.Get = function(name) {
			
			return name in _headers ? _headers[name] : undefined;
		}
		this.Is = function(name, value) {
			
			return name in _headers && _headers[name].toLowerCase() == value.toLowerCase();
		}
		this.Remove = function(name) {
			
			delete _headers[name];
		}
		this.Serialize = function() {
			
			var tmp = '';
			for ( var [h,v] in Iterator(_headers) )
				tmp += h + ': ' + v + CRLF;
			return tmp;
		}
	}



	function CreateHttpHeaders( statusCode, protoVersion, headers ) {

		var buf = 'HTTP/' + protoVersion + SPC + statusCode + SPC + reasonPhrase[statusCode] + CRLF;
		return buf + headers.Serialize() + CRLF;
	}

	
	function ParseQueryData(str) {
		
		var map = NewDataObj();
		if ( str )
			for each ( var p in str.split('&') )
				let ( [key, val] = p.split('=') ) // report a "strict warning: reference to undefined property 1" because 'foo'.split('=') do not have a [1]
					map[key] = val;
		return map;
	}
	
	function ParseCookieData(str) {
		
		var map = NewDataObj();
		if ( str )
			for each ( var p in str.split('; ') )
				let ( [key, val] = p.split('=') )
					map[key] = val;
		return map;
	}


	function NormalizePath( path ) { // (TBD) try with regexp

		var epath = path.split('/');
		var newPath = [];
		for each ( var name in epath )
			switch (name) {
			case '..':
				newPath.pop();
				break;
			case '.':
			case '':
				break;
			default:
				newPath.push(name);
			}
		return newPath.join('/');
	}


	function ProcessFileRequest(req) {

		var root='./';
		var data = '';
		
		var fileName = root + NormalizePath(req.iStatus.path);
		var file = new File( fileName );
		if ( !file.exist || file.info.type != File.FILE_FILE ) {

			var message = 'file '+fileName+' not found';
			req.oHeaders.Set('Content-Length', message.length);
			req.oHeaders.Set('Content-Type', 'text/plain');
			req.Respond(404)(message);
			return;
		}
		
		req.OnBodyData = function(buf) data += buf;

		req.OnEndOfBody = function() {

			req.oHeaders.Set('Content-Type', MimeTypeByFileName(fileName));

			var useChunksEncoding = false;
			if (req.iStatus.protoVersion >= 1.1) {
			
				useChunksEncoding = true;				
				req.oHeaders.Set('Transfer-Encoding', 'chunked');
			}

			var ContentEncoding = Identity;
			if ( req.iHeaders.Has('Accept-Encoding') && req.iHeaders.Get('Accept-Encoding').indexOf('deflate') != -1 ) {

				req.oHeaders.Set('Content-Encoding', 'deflate');
				ContentEncoding = new Z(Z.DEFLATE);
			}

			file.Open( File.RDONLY );
			req.Respond(200);
			req.Send( function() {

				var data = file.Read(Z.idealInputLength);
				if ( data.length ) {

					data = ContentEncoding(data);
					if ( useChunksEncoding )
						return [ data.length.toString(16) + CRLF, data, CRLF ];
					else
						return [ data ];
				}
				data = ContentEncoding();
				if ( useChunksEncoding )
					return [ data.length.toString(16) + CRLF, data, CRLF ];
				else
					return [ data ];
					
				file.Close();
				return false;
			}, true );
			if ( useChunksEncoding )
				req.Send( '0' + CRLF + CRLF, true );
		}
	}



	
    function IrcTextToWeb(text) {
        
        var colors = { 0:'FFF', 1:'000', 2:'007', 3:'070', 4:'F00', 5:'700', 6:'909', 7:'F70', 
                       8:'FF0', 9:'0F0', 10:'077', 11:'0FF', 12:'00F', 13:'F0F', 14:'777', 15:'DDD' };
        var lines = text.split('\x03');
        var end = '';
        for ( var i=1; i<lines.length; i++ ) {
            
            var [m,fg,bg] = /^(\d{1,2})(?:,(\d{1,2}))?/(lines[i]);
            var html = '';
            html += isNaN(fg)?'':('color:#'+colors[fg]+';');
            html += isNaN(bg)?'':('background-color:#'+colors[bg]+';');
            lines[i] = '<span style="'+html+'">'+lines[i].substr(m.length);;
            end += '</span>';
        }
        return lines.join('')+end;
    }


	function TermIrc(term) {
		
		var _currentChan;
		term.Send('Welcome to the IRC term<br/> HELP:<br/> /j &lt;channel&gt; : join<br/> /q : quit<br/> /names : name list<br/>');
		
		term.OnRequest = function(data) {
			
			if ( !data )
				return;

			if ( data[0] == '/' ) {
				
				var arg = ParseArguments(data.substr(1));
				switch (arg[0].toLowerCase()) {
					case 'q':
						$A.RemoveModuleListener(listener);
						InitTermSession(term);
						break;
					case 'j':
						_currentChan = $A.NormalizeChannelName((arg[1][0] == '#' ? '' : '#') + arg[1]);
						$A.Join( _currentChan );
						term.Send('* Now talking in '+_currentChan+'<br/>');
						break;
					case 'names':
						var names = '';
						for ( let name in $D.channel[_currentChan].names )
							names += ($A.IsVoice(_currentChan, name)?'+':'') + ($A.IsOp(_currentChan, name)?'@':'') + name + '  ';
						term.Send(names+'<br/>');
						break;
					default:
						term.Send('unknown command<br/>');
				}
			} else {
				
				_currentChan && $A.Privmsg( _currentChan, data );
				term.Send( '<i>'+_currentChan+'</i> &lt;'+getData($D.nick)+'&gt; '+data+'<br/>' );
			}
		}

		var listener = { ircMsg: {
			PRIVMSG: function( tmp, command, from, to, msg ) {
				
				to = $A.NormalizeChannelName(to);
				if ( _currentChan && to == _currentChan )
					term.Send( '<i>' + to + '</i> &lt;' + StrBefore(from, '!') +'&gt; ' + IrcTextToWeb(msg) + '<br/>' );
			}
		}};
		$A.AddModuleListener(listener);
		term.OnClose = function() $A.RemoveModuleListener(listener);
	}


	function InitTermSession(term) {
		
		term.Send('Login as: ');
		term.OnRequest = function(data) {
			
			term.Send(data+'<br/>password: ');
			term.OnRequest = function(data) {
				
				term.Send(StringRepeat('*', data.length)+'<br/><br/>');
				if ( data == getData($MD.termPasword) ) {
					
					TermIrc(term);
				} else {
					term.Send('<span style="color:red">Invalid password, bye.</span><br/>');
					term.Close();
				}
			}
		}
		term.OnClose = Noop;
	}



	function InitTermSession(term) {
		
		var i = 0, j = 0;
		term.Send('cout','Ready.<br/>');
		io.AddTimeout( 1000, function() {
		
			term.Send && term.Send('cout', i+'<br/>');
			io.AddTimeout( 3000, arguments.callee );
			i++;
		});

		term.OnRequest = function(name, data) {
			
			if ( name != 'cin' )
				return;
			
			j++;
			if ( data == 'red' ) {
				term.Send('#in { color: red }', 'text/css');
			}
			
			term.Send('cout','echo '+j+':'+data+'<br/>');
		}

		term.OnClose = function() {
		}
	}
/*
*/	




	
	var _terms = NewDataObj();
//	INSPECT.push(function() 'CONSOLES '+_terms.length+':'+[desc.peerPort+':'+desc.peerName for each ( desc in _descriptorList )].join(' ')+' ');
	
	function CloseAllTerms() {

		for each ( var c in _terms )
			c.pub.Close && c.pub.Close();
	}
	
	function ProcessTermAccess(req) {

		var query = ParseQueryData(req.iStatus.query);
		var cookie = ParseCookieData(req.iHeaders.Get('Cookie'));
		var action = query.action;
		var term = _terms[cookie.sid];
		
		if ( !action ) { // new session ( ... && !term ??? )
			
//			var prevHistory;
//			if (term)
//				prevHistory = term.history;
			
			let sid = RandomString(32);
			_terms[sid] = term = { pub:{}, history:[], pendingMessagesQueue:[] };

			term.pub.Send = function(/*...*/) { // pub.Send is  data, type  not  [data, type]

				if ( term.history.length > 100 )
					term.history.shift();
				var item = Array.slice(arguments);
				term.history.push(item);
				term.pendingMessagesQueue.push(item);
				term.Send && term.Send();
			}
			
			term.pub.Close = function() {
				
				delete term.pub.Close; // avoid Close() to be called in OnClose()
				delete term.pub.OnRequest;
				term.pub.OnClose && term.pub.OnClose();
				delete term.pub.Send;
				term.ResetTimeout();
				delete _terms[sid];
				ReportNotice( 'remoteTerm' + req.peerName + ' close' );
			}

			term.ResetTimeout = function(time) {
			
				term.timeout && io.RemoveTimeout(term.timeout);
				if (time)
					term.timeout = io.AddTimeout( time, function() term.pub.Close() );
			}
			
			var content = new File('./webTerm.html').content; // (TBD) filename from config
			req.oHeaders.Set('cache-control', 'no-store'); // cf. http://developer.mozilla.org/en/docs/Using_Firefox_1.5_caching
			req.oHeaders.Set('Content-Length', content.length);
			req.oHeaders.Set('Set-Cookie', 'sid='+sid+'; path='+req.iStatus.path); // Set-Cookie: <name>=<value>[; <name>=<value>]... [; expires=<date>][; domain=<domain_name>][; path=<some_path>][; secure][; httponly]
			req.Respond(200)(content);
			req.End();
			ReportNotice( 'remoteTerm' + req.peerName + ' create' );

			var consoleWebModule = new File('./webConsole.js').content; // (TBD) filename from config

			term.pub.Send( 'AddModule', consoleWebModule );

//			if ( prevHistory ) {
//				
//				for each ( let item in prevHistory )
//					term.Send(item);
//				delete prevHistory;
//			}
			InitTermSession(term.pub);
			return;
		}

		if ( !term ) {
			
			let message = '<span style="color:red">Invalid session.</span><br/>';
			req.oHeaders.Set('Content-Length', message.length);
			req.oHeaders.Set('Connection', 'close'); // needed to ignore request body !! else, we need to read it !
			req.Respond(404)(message);
			req.End();
			return;
		}
		
		term.ResetTimeout(getData($MD.termSessionTimeout));

		function SendItemList(req, itemList) {

			var data = EncodeArray([ EncodeArray(item) for each (item in itemList) ]);
			itemList.splice(0);
			if ( data.length >= 128 && req.iHeaders.Has('Accept-Encoding') && req.iHeaders.Get('Accept-Encoding').indexOf('deflate') != -1 ) {

				req.oHeaders.Set('Content-Encoding', 'deflate');
				data = new Z(Z.DEFLATE)(data, true);
			}
			req.oHeaders.Set('Content-Type', 'application/x-www-form-urlencoded');
			req.oHeaders.Set('Content-Length', data.length);
			req.Respond(200)(data);
			req.End();
		}
		
		switch (action) {
		
			case 'wait':
				if ( term.pendingMessagesQueue.length ) {
					
					SendItemList(req, term.pendingMessagesQueue);
					delete term.Send;
					return;
				}
				term.Send = function(item) {

					req.Respond && SendItemList(req, term.pendingMessagesQueue);
					delete term.Send;
				}
				return;

			case 'submit':
				req._termData = '';
				req.OnBodyData = function(buf) req._termData += buf;
				req.OnEndOfBody = function() {

					ReportNotice( 'remoteTerm' + req.peerName + ' data: ' + req._termData );
					let prevSend = term.Send||undefined; // save the previous Send method because it may be a pending wait
					delete term.Send;
					for each ( let item in DecodeArray(req._termData) )
						term.pub.OnRequest && term.pub.OnRequest.apply(term.pub, DecodeArray(item));
					delete req._termData; // _termData is tmp.
					SendItemList(req, term.pendingMessagesQueue);
					term.Send = prevSend;
				}
				return;
				
			case 'history': // note that the history can be managed client-side
				var historyWithoutPendingItems = term.history.slice(0,term.history.length-term.pendingMessagesQueue.length); // remove the pending data that will be send later
				SendItemList(req, historyWithoutPendingItems);
				return;
		}
	}







	var totalConnectionCount = 0;
	var requestHandlerList = {};
	
	function FindRequestHandler(path) {
		
		for each ( var [match, requestHandler] in requestHandlerList )
			if ( match(path) )
				return requestHandler;
		return undefined;
	}
	

	function Respond(statusCode, protoVersion) {
		
		delete this.Respond; // we can respond only once
		protoVersion = protoVersion || this.iStatus.protoVersion;
		var connectionKeepAliveMax = getData($MD.connectionKeepAliveMax);
		if ( this.iStatus.protoVersion >= 1.1 && this.iHeaders.Is('Connection', 'keep-alive') && !this.oHeaders.Is('Connection', 'close') && this.count <= connectionKeepAliveMax && (this.oHeaders.Has('Content-Length') || this.oHeaders.Is('Transfer-Encoding', 'chunked')) ) {

			this.oHeaders.Set('Connection', 'keep-klive' );
			this.oHeaders.Set('Keep-Alive', 'timeout='+(getData($MD.connectionKeepAliveTimeout)/SECOND).toFixed()+', max='+(connectionKeepAliveMax-this.count) );
		} else {
			this.oHeaders.Set('Connection', 'close');
		}
		this.Send( CreateHttpHeaders( statusCode, protoVersion, this.oHeaders ) );
		return this.Send;
	}
			
	
	function ProcessHttpConnection(connection) {

		totalConnectionCount++;
		
//DPrint( 'NEW CONNECTION, count:', totalConnectionCount, Now() );

		var input = new Buffer();
		var connectionDataRate = new SingleRateMeter(getData($MD.connectionDataRate));

		var count = 0, timeout;
		var req = {}, OnData = ProcessHttpHeader;

		function ResetTimeout(time) {
			
			io.RemoveTimeout(timeout);
			if ( time )
				timeout = io.AddTimeout(time, Disconnect);
		}

		ResetTimeout(1*SECOND); // after accepting the connection, let 1 second to the client to send headers, else bye.

		connection.OnData = function() {
			
			var data = connection.Read();
			input.Write(data);
			OnData();
			if ( !connectionDataRate.Inc(data.length) )
				connection.Sleep( connectionDataRate.RestTime() );
		}

		connection.OnDisconnected = function() {

			ResetTimeout();
			totalConnectionCount--;
			delete req.Respond;
			delete req.Send;
			delete req.End;
			req.OnDisconnected && req.OnDisconnected();
			connection.Close();
		}
		
		function Send(item) connection.Write(item, true);
		
		function ProcessHttpHeader() {
			
			OnData = arguments.callee;

			if ( input.length > 8*KILOBYTE ) { // invalid headers size
				
				ResetTimeout();
				connection.Close();
				ReportWarning( _name + ' incoming HTTP request header too long ('+input.length+')' )
//				connection.Disconnect(); // (TBD) should be less gentle
				return;
			}	

			if ( input.IndexOf(CRLF+CRLF) == -1 )
				return;

			ResetTimeout(getData($MD.connectionKeepAliveTimeout));
			delete req.Respond; // the previous request is dead, references on it are legal but useless
			delete req.Send;
			delete req.End;
			req = {};
			req.count = ++count;
			req.peerName = connection.peerName;
			req.iStatus = ParseHttpStatus(input);
			req.iHeaders = ParseHttpHeaders(input);
			req.oHeaders = new HttpHeaders();
			req.oHeaders.MSet({ 
				'Date':new Date().toUTCString(),
				'Server':_name,
				'Expires':'0',
				'Cache-Control':'no-cache',
//				'Pragma':'no-cache',
				'Content-Type':'text/html'
			}); // beware: do not set 'Connection' or 'Content-Length'
			req.remainingBodyLength = req.iHeaders.Get('Content-Length');

			ReportNotice( _name + ' incoming HTTP request: ' + req.iStatus.method + ' ' + req.iStatus.url ); // req.iHeaders.Serialize() 

			req.Respond = Respond;
			req.Send = Send;
			req.End = function() {
				
				delete req.End;
				if ( req.oHeaders.Is('Connection', 'close') )
					Disconnect();
			}
			var requestHandler = FindRequestHandler(req.iStatus.path);
			if ( !requestHandler ) {

				var message = 'Unable to handle ' + req.iStatus.path;
				req.oHeaders.MSet({'Content-Length':message.length, 'Content-Type':'text/plain' /*, 'Connection':'close'*/});
				req.Respond(404)(message);
				req.End();
				return;
			}

			requestHandler(req); // ***

			if ( req.remainingBodyLength > 0 ) // (string > number) is valid
				ProcessHttpBody();
			else
				ProcessEndOfRequest();
		}


		function ProcessHttpBody() {

			OnData = arguments.callee;
			if ( !input.length )
				return;
			
			if ( input.length >= req.remainingBodyLength ) {

				req.OnBodyData && req.OnBodyData(input.Read(req.remainingBodyLength)); // ***
				req.remainingBodyLength = 0;
			} else {
			
				req.remainingBodyLength -= input.length;
				req.OnBodyData && req.OnBodyData(input.Read()); // ***
			}

			if ( req.remainingBodyLength == 0 )
				ProcessEndOfRequest();
		}
		
		
		function ProcessEndOfRequest() {
			
			OnData = Noop;

			if ( !req.End ) {

				ProcessHttpHeader();
				return;
			}
			
			req.End = function() {

				delete req.End;
				if ( req.oHeaders.Is('Connection', 'close') )
					Disconnect();
				else
					ProcessHttpHeader();
			}

			req.OnEndOfBody && req.OnEndOfBody(); // ***
		}
		
		
		function Disconnect() {

			req.Send( function() void connection.Disconnect() ); // req.Send && ???
			delete req.Respond;
			delete req.Send;
			delete req.End;
			OnData = Noop;
		}
	}




	var serverConnection;

	function StartServer() {

		var incomingConnectionRatePerPeer = new MultiRateMeter(getData($MD.incomingConnectionRatePerPeer));
		serverConnection = new TCPServer( getData($MD.port), getData($MD.bind), getData($MD.socketBackLog) );
		serverConnection.OnIncoming = function(connection) {
		
			if ( totalConnectionCount <= getData($MD.maxConnections) && incomingConnectionRatePerPeer.Inc(connection.peerName, 1) ) {
			
				ProcessHttpConnection(connection);
			} else {
			
				if ( incomingConnectionRatePerPeer.Ratio(connection.peerName) < 2 ) {
	
					connection.Write('HTTP/1.1 503 Service Unavailable'+CRLF+'Retry-After: 2'+CRLF+'Connection: close'+CRLF+CRLF, true); // warning
					connection.Write(function() connection.Disconnect());
					return;
				}
				connection.Close(); // hard close.
				serverConnection.Sleep(500); // ignore incomming connections for a while
			}
		}
	}

	function StopServer() {
		
		serverConnection.Close();
	}


	this.moduleApi = {
		
		AddRequestHandler: function( pathRegExpr, requestHandlerConstructor ) requestHandlerList[String(pathRegExpr)] = [pathRegExpr, requestHandlerConstructor],
		RemoveRequestListener: function( pathRegExpr ) delete requestHandlerList[String(pathRegExpr)]
	};


	this.stateListener = [
		{
			set: function(s) s[STATE_RUNNING] && s[_name],
			reset: function(s) !s[STATE_RUNNING] || !s[_name],
			trigger: function(polarity) {
			
				if (polarity) {
					
					StartServer();
//					$A.AddRequestHandler( /^\/doc\//, ProcessFileRequest );
					$A.AddRequestHandler( /^\/cons/, ProcessTermAccess );
				} else {
					
					StopServer();

					//CloseHttpConnections(); // (TBD)

					CloseAllTerms();
				}
				
			}
		}
	];	

})
